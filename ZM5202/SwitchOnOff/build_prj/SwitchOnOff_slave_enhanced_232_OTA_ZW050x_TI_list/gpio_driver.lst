C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE GPIO_DRIVER
OBJECT MODULE PLACED IN .\build_prj\SwitchOnOff_slave_enhanced_232_OTA_ZW050x_TI_Rels\gpio_driver.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\APPLICATIONUTILITIES\GPIO_DRIVER.C LARGE OBJECTADVANCED WARNINGLEVEL(
                    -1) OPTIMIZE(11,SIZE) BROWSE NOINTPROMOTE INTVECTOR(0X1800) INCDIR(..\..\Z-WAVE\INCLUDE;..\..\Z-WAVE\IO_DEFINES;.\BUILD_P
                    -RJ;.\BUILD_PRJ\SWITCHONOFF_SLAVE_ENHANCED_232_OTA_ZW050X_TI_RELS;.\BUILD_PRJ\SWITCHONOFF_SLAVE_ENHANCED_232_OTA_ZW050X_T
                    -I;C:\KEIL_V5\C51\INC;..\APPLICATIONUTILITIES;..\APPLICATIONCOMMANDHANDLERS;..\..\ZLIB\CMDCLASS;..\..\ZLIB\DEVTYPES;..\..
                    -\ZLIB\HANDLER;..\Valve_fucntion) DB OE NOCO SB LC CD DEFINE(BOOTLOADER_ENABLED,slave_enhanced_232,US,ZAF_BUILD_NO=52445,
                    -ZW_SECURITY_PROTOCOL,ZW_SLAVE,ZW_SLAVE_32,ZW_SLAVE_ENHANCED_232,ZW_SLAVE_ROUTING,ZW050x,ZW0501,NEW_NODEINFO,ZW_SELF_HEAL
                    -,BANKING,TEST_INTERFACE_SUPPORT,ZW_TEST_INTERFACE_DRIVER,NON_BATT,ZW_SMARTSTART_ENABLED,BOOTLOADER_ENABLED,slave_enhance
                    -d_232,US,ZAF_BUILD_NO=52445,ZW_SECURITY_PROTOCOL,ZW_SLAVE,ZW_SLAVE_32,ZW_SLAVE_ENHANCED_232,ZW_SLAVE_ROUTING,ZW050x,ZW05
                    -01,NEW_NODEINFO,ZW_SELF_HEAL,BANKING,TEST_INTERFACE_SUPPORT,ZW_TEST_INTERFACE_DRIVER,NON_BATT,ZW_SMARTSTART_ENABLED) DEB
                    -UG PRINT(.\build_prj\SwitchOnOff_slave_enhanced_232_OTA_ZW050x_TI_list\gpio_driver.lst) TABS(2) OBJECT(.\build_prj\Switc
                    -hOnOff_slave_enhanced_232_OTA_ZW050x_TI_Rels\gpio_driver.obj)

line level    source

   1          /**
   2           * @file gpio_driver.c
   3           *
   4           * @copyright Copyright (c) 2001-2017
   5           * Sigma Designs, Inc.
   6           * All Rights Reserved
   7           *
   8           * @brief Offers functions for controlling GPIO.
   9           *
  10           * @details This driver includes pin swap because certain Z-Wave development
  11           * boards have pins which are swapped. This driver takes the pin swap into
  12           * account.
  13           *
  14           * The GPIO driver is dependent on config_pin.c which must be placed in the
  15           * application folder and implement an array of PIN_T type and the function
  16           * gpio_GetPinSwapList externally declared in the header file for the GPIO
  17           * driver.
  18           *
  19           * @date 08/05/2015
  20           * @author Thomas Roll
  21           * @author Christian Salmony Olsen
  22           */
  23          
  24          /***************************************************************************/
  25          /*                              INCLUDE FILES                              */
  26          /***************************************************************************/
  27          
  28          #include <ZW_pindefs.h>
   1      =1  /****************************************************************************
   2      =1   *
   3      =1   * Copyright (c) 2001-2011
   4      =1   * Sigma Designs, Inc.
   5      =1   * All Rights Reserved
   6      =1   *
   7      =1   *---------------------------------------------------------------------------
   8      =1   *
   9      =1   * Description: In/Out definitions Z-Wave Single Chips
  10      =1   *
  11      =1   * Author:   Ivar Jeppesen
  12      =1   *
  13      =1   * Last Changed By:  $Author: efh $
  14      =1   * Revision:         $Revision: 23305 $
  15      =1   * Last Changed:     $Date: 2012-09-04 08:36:50 +0200 (ti, 04 sep 2012) $
  16      =1   *
  17      =1   ****************************************************************************/
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 2   

  18      =1  #ifndef _ZW_PINDEFS_H_
  19      =1  #define _ZW_PINDEFS_H_
  20      =1  
  21      =1  /****************************************************************************/
  22      =1  /*                              INCLUDE FILES                               */
  23      =1  /****************************************************************************/
  24      =1  #ifdef __C51__
  25      =1  #include <ZW_typedefs.h>
   1      =2  /*******************************  ZW_typedefs.h  *******************************
   2      =2   *           #######
   3      =2   *           ##  ##
   4      =2   *           #  ##    ####   #####    #####  ##  ##   #####
   5      =2   *             ##    ##  ##  ##  ##  ##      ##  ##  ##
   6      =2   *            ##  #  ######  ##  ##   ####   ##  ##   ####
   7      =2   *           ##  ##  ##      ##  ##      ##   #####      ##
   8      =2   *          #######   ####   ##  ##  #####       ##  #####
   9      =2   *                                           #####
  10      =2   *          Products that speak Z-Wave work together better
  11      =2   *
  12      =2   *              Copyright (c) 2008
  13      =2   *              Zensys A/S
  14      =2   *              Denmark
  15      =2   *
  16      =2   *              All Rights Reserved
  17      =2   *
  18      =2   *    This source file is subject to the terms and conditions of the
  19      =2   *    Zensys Software License Agreement which restricts the manner
  20      =2   *    in which it may be used.
  21      =2   *
  22      =2   *---------------------------------------------------------------------------
  23      =2   *
  24      =2   * Description: Module description
  25      =2   *
  26      =2   * Author:   Ivar Jeppesen
  27      =2   *
  28      =2   * Last Changed By:  $Author: efh $
  29      =2   * Revision:         $Revision: 29359 $
  30      =2   * Last Changed:     $Date: 2014-07-11 11:13:33 +0200 (fr, 11 jul 2014) $
  31      =2   *
  32      =2   ****************************************************************************/
  33      =2  #ifndef _ZW_TYPEDEFS_H_
  34      =2  #define _ZW_TYPEDEFS_H_
  35      =2  
  36      =2  #ifndef __C51__
  44      =2  
  45      =2  /****************************************************************************/
  46      =2  /*                              INCLUDE FILES                               */
  47      =2  /****************************************************************************/
  48      =2  
  49      =2  /****************************************************************************/
  50      =2  /*                     EXPORTED TYPES and DEFINITIONS                       */
  51      =2  /****************************************************************************/
  52      =2  #ifndef BYTE
  53      =2  typedef unsigned char   BYTE;
  54      =2  typedef unsigned short  WORD;
  55      =2  typedef unsigned long   DWORD;
  56      =2  
  57      =2  #define IIBYTE BYTE idata  /* Internal indexed data byte */
  58      =2  #define IBYTE  BYTE data   /* Internal data byte */
  59      =2  #define IWORD  WORD data   /* Internal data word */
  60      =2  #define IDWORD DWORD data  /* Internal data double word*/
  61      =2  
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 3   

  62      =2  #define XBYTE  BYTE xdata  /* External data byte */
  63      =2  #define XWORD  WORD xdata  /* External data word */
  64      =2  #define XDWORD DWORD xdata /* External data double word */
  65      =2  #define BBYTE  BYTE bdata  /* Internal bit adressable byte */
  66      =2  
  67      =2  #define PBYTE  XBYTE
  68      =2  #define PWORD  XWORD
  69      =2  #define PDWORD XDWORD
  70      =2  
  71      =2  #define BOOL   bit         /* Internal bit */
  72      =2  
  73      =2  #define CODE   code        /* Used for defining callback function which allways */
  74      =2                             /* resides in code space. */
  75      =2  
  76      =2  typedef BYTE * BYTE_P;
  77      =2  typedef WORD * WORD_P;
  78      =2  typedef DWORD * DWORD_P;
  79      =2  
  80      =2  typedef struct
  81      =2  {
  82      =2    BYTE anything;
  83      =2  } sSomeXDATA4K;
  84      =2  typedef sSomeXDATA4K * XDATA4K_P;
  85      =2  #endif
  86      =2  
  87      =2  #ifndef EOF
  88      =2  #define EOF (-1)
  89      =2  #endif
  90      =2  
  91      =2  #ifndef NULL
  92      =2  #define NULL  (0)
  93      =2  #endif
  94      =2  
  95      =2  #ifndef TRUE
  96      =2  #define TRUE  (1)
  97      =2  #define FALSE (0)
  98      =2  #endif
  99      =2  
 100      =2  /* Define for making easy and consistent callback definitions */
 101      =2  #define VOID_CALLBACKFUNC(completedFunc)  void (CODE *completedFunc)
 102      =2  
 103      =2  /* Remove memory specifier byte from generic pointer
 104      =2     See also: http://www.keil.com/forum/3443/ */
 105      =2  #ifdef __C51__
 106      =2  #define STRIP_GENERIC_PTR(p) ((unsigned) (void *) (p))
 107      =2  /* Macros to test generic pointers for NULL-ness, even if they
 108      =2  have been promoted from memory specific pointers */
 109      =2  #define IS_NULL(x)  (STRIP_GENERIC_PTR(x) == 0)
 110      =2  #define NON_NULL(x) (STRIP_GENERIC_PTR(x) != 0)
 111      =2  #else
 115      =2  
 116      =2  #define UNUSED(x) x = x; /* Hack to silence warning C280 Unreferenced local variable */
 117      =2  #define UNUSED_CONST(x) if(x) ; /* Hack to silence warning C280 Unreferenced const variable */
 118      =2  
 119      =2  #define UIP_HTONL(x) x // C51 is big endian by default
 120      =2  
 121      =2  /****************************************************************************/
 122      =2  /*                                 MACROS                                   */
 123      =2  /****************************************************************************/
 124      =2  
 125      =2  /* offset of field m in a struct s */
 126      =2  #ifndef offsetof
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 4   

 127      =2  #define offsetof(s,m)   (WORD)( (BYTE_P)&(((s *)0)->m) - (BYTE_P)0 )
 128      =2  #endif
 129      =2  
 130      =2  
 131      =2  #endif /* _ZW_TYPEDEFS_H_ */
  26      =1  #endif /* __C51__ */
  27      =1  
  28      =1  /****************************************************************************/
  29      =1  /*                     EXPORTED TYPES and DEFINITIONS                       */
  30      =1  /****************************************************************************/
  31      =1  /*!!!WARNING DO NOT MODIFY THESE VARIABLES ONLY USED BY THE Z-WAVE STACK !!!*/
  32      =1  #ifdef __C51__
  33      =1  extern IBYTE P0Shadow;
  34      =1  extern IBYTE P1Shadow;
  35      =1  extern IBYTE P2Shadow;
  36      =1  extern IBYTE P3Shadow;
  37      =1  
  38      =1  extern IBYTE P0ShadowDIR;
  39      =1  extern IBYTE P1ShadowDIR;
  40      =1  extern IBYTE P2ShadowDIR;
  41      =1  extern IBYTE P3ShadowDIR;
  42      =1  #endif /* __C51__ */
  43      =1  
  44      =1  
  45      =1  #ifdef __C51__
  46      =1  /* Macros for I/O Port controlling */
  47      =1  
  48      =1  /* Set I/O pin as input:
  49      =1   *    pin     - Z-Wave pin name
  50      =1   *    pullup  - if not zero activate the internal pullup resistor
  51      =1   */
  52      =1  #if defined (ZW040x) || defined(ZW050x)
  53      =1  /*Fix TO#02731*/
  54      =1  #define PIN_IN(pin,pullup)  {pin##DIR_PAGE;(pin##SHADOWDIR |= (1<<pin)); (pullup)?(pin##SHADOW &=~(1<<pin)
             -):(pin##SHADOW |= (1<<pin));pin##Port = pin##SHADOW;pin##DIR = pin##SHADOWDIR;}
  55      =1  #endif /* #if defined (ZW040x) || defined(ZW050x) */
  56      =1  
  57      =1  
  58      =1  /* Set I/O pin as output:
  59      =1   *    pin     - Z-Wave pin name
  60      =1   */
  61      =1  #if defined (ZW040x) || defined(ZW050x)
  62      =1  #define PIN_OUT(pin)  {pin##DIR_PAGE;(pin##SHADOWDIR &=~(1<<pin)) ;(pin##DIR = pin##SHADOWDIR);}
  63      =1  #endif /* #if defined (ZW040x) || defined(ZW050x) */
  64      =1  
  65      =1  
  66      =1  /* Read pin value:
  67      =1   *    pin     - Z-Wave pin name
  68      =1   */
  69      =1  #define PIN_GET(pin)  (pin##Port & (1<<pin))
  70      =1  
  71      =1  /* Set output pin to 1:
  72      =1   *    pin     - Z-Wave pin name
  73      =1   */
  74      =1   /*Fix TO#02731*/
  75      =1  #define PIN_ON(pin)  {pin##SHADOW |= (1<<pin);pin##Port = pin##SHADOW;}
  76      =1  #define PIN_HIGH(pin) {pin##SHADOW |= (1<<pin);pin##Port = pin##SHADOW;}
  77      =1  
  78      =1  /* Set output pin to 0:
  79      =1   *    pin     - Z-Wave pin name
  80      =1   */
  81      =1   /*Fix TO#02731*/
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 5   

  82      =1  #define PIN_OFF(pin) {pin##SHADOW &= ~(1<<pin);pin##Port = pin##SHADOW;}
  83      =1  #define PIN_LOW(pin) {pin##SHADOW &= ~(1<<pin);pin##Port = pin##SHADOW;}
  84      =1  
  85      =1  /* Toggle output pin:
  86      =1   *    pin     - Z-Wave pin name
  87      =1   */
  88      =1   /*Fix TO#02731*/
  89      =1  #define PIN_TOGGLE(pin) {pin##SHADOW ^= (1<<pin);pin##Port = pin##SHADOW;}
  90      =1  
  91      =1  /* Button pressed */
  92      =1  #define BUTTON_PRESSED() ((PIN_GET(Button))?0:1)
  93      =1  
  94      =1  #endif
  95      =1  
  96      =1  
  97      =1  #if defined (ZW040x) || defined(ZW050x)
  98      =1  
  99      =1  /* Z-Wave Button - INT1 */
 100      =1  #define ButtonPort          P1
 101      =1  #define ButtonSHADOW        P1Shadow
 102      =1  #define ButtonDIR           P1DIR
 103      =1  #define ButtonSHADOWDIR     P1ShadowDIR
 104      =1  #define ButtonDIR_PAGE      P1DIR_PAGE;
 105      =1  #define Button              1
 106      =1  
 107      =1  
 108      =1  /*ZW-Wave  EEPROM CS */
 109      =1  #define EECSPort          P2
 110      =1  #define EECSSHADOW        P2Shadow
 111      =1  #define EECSDIR           P2DIR
 112      =1  #define EECSSHADOWDIR     P2ShadowDIR
 113      =1  #define EECSDIR_PAGE      P2DIR_PAGE
 114      =1  #define EECS              5
 115      =1  
 116      =1  #define P00Port          P0
 117      =1  #define P00SHADOW        P0Shadow
 118      =1  #define P00DIR           P0DIR
 119      =1  #define P00SHADOWDIR     P0ShadowDIR
 120      =1  #define P00DIR_PAGE      P0DIR_PAGE
 121      =1  #define P00              0
 122      =1  
 123      =1  #define P01Port          P0
 124      =1  #define P01SHADOW        P0Shadow
 125      =1  #define P01DIR           P0DIR
 126      =1  #define P01SHADOWDIR     P0ShadowDIR
 127      =1  #define P01DIR_PAGE      P0DIR_PAGE
 128      =1  #define P01              1
 129      =1  
 130      =1  #define P02Port          P0
 131      =1  #define P02SHADOW        P0Shadow
 132      =1  #define P02DIR           P0DIR
 133      =1  #define P02SHADOWDIR     P0ShadowDIR
 134      =1  #define P02DIR_PAGE      P0DIR_PAGE
 135      =1  #define P02              2
 136      =1  
 137      =1  #define P03Port          P0
 138      =1  #define P03SHADOW        P0Shadow
 139      =1  #define P03DIR           P0DIR
 140      =1  #define P03SHADOWDIR     P0ShadowDIR
 141      =1  #define P03DIR_PAGE      P0DIR_PAGE
 142      =1  #define P03              3
 143      =1  
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 6   

 144      =1  #define P04Port          P0
 145      =1  #define P04SHADOW        P0Shadow
 146      =1  #define P04DIR           P0DIR
 147      =1  #define P04SHADOWDIR     P0ShadowDIR
 148      =1  #define P04DIR_PAGE      P0DIR_PAGE
 149      =1  #define P04              4
 150      =1  
 151      =1  #define P05Port          P0
 152      =1  #define P05SHADOW        P0Shadow
 153      =1  #define P05DIR           P0DIR
 154      =1  #define P05SHADOWDIR     P0ShadowDIR
 155      =1  #define P05DIR_PAGE      P0DIR_PAGE
 156      =1  #define P05              5
 157      =1  
 158      =1  #define P06Port          P0
 159      =1  #define P06SHADOW        P0Shadow
 160      =1  #define P06DIR           P0DIR
 161      =1  #define P06SHADOWDIR     P0ShadowDIR
 162      =1  #define P06DIR_PAGE      P0DIR_PAGE
 163      =1  #define P06              6
 164      =1  
 165      =1  #define P07Port          P0
 166      =1  #define P07SHADOW        P0Shadow
 167      =1  #define P07DIR           P0DIR
 168      =1  #define P07SHADOWDIR     P0ShadowDIR
 169      =1  #define P07DIR_PAGE      P0DIR_PAGE
 170      =1  #define P07              7
 171      =1  
 172      =1  #define P10Port          P1
 173      =1  #define P10SHADOW        P1Shadow
 174      =1  #define P10DIR           P1DIR
 175      =1  #define P10SHADOWDIR     P1ShadowDIR
 176      =1  #define P10DIR_PAGE      P1DIR_PAGE
 177      =1  #define P10              0
 178      =1  
 179      =1  #define P11Port          P1
 180      =1  #define P11SHADOW        P1Shadow
 181      =1  #define P11DIR           P1DIR
 182      =1  #define P11SHADOWDIR     P1ShadowDIR
 183      =1  #define P11DIR_PAGE      P1DIR_PAGE
 184      =1  #define P11              1
 185      =1  
 186      =1  #define P12Port          P1
 187      =1  #define P12SHADOW        P1Shadow
 188      =1  #define P12DIR           P1DIR
 189      =1  #define P12SHADOWDIR     P1ShadowDIR
 190      =1  #define P12DIR_PAGE      P1DIR_PAGE
 191      =1  #define P12              2
 192      =1  
 193      =1  #define P13Port          P1
 194      =1  #define P13SHADOW        P1Shadow
 195      =1  #define P13DIR           P1DIR
 196      =1  #define P13SHADOWDIR     P1ShadowDIR
 197      =1  #define P13DIR_PAGE      P1DIR_PAGE
 198      =1  #define P13              3
 199      =1  
 200      =1  #define P14Port          P1
 201      =1  #define P14SHADOW        P1Shadow
 202      =1  #define P14DIR           P1DIR
 203      =1  #define P14SHADOWDIR     P1ShadowDIR
 204      =1  #define P14DIR_PAGE      P1DIR_PAGE
 205      =1  #define P14              4
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 7   

 206      =1  
 207      =1  #define P15Port          P1
 208      =1  #define P15SHADOW        P1Shadow
 209      =1  #define P15DIR           P1DIR
 210      =1  #define P15SHADOWDIR     P1ShadowDIR
 211      =1  #define P15DIR_PAGE      P1DIR_PAGE
 212      =1  #define P15              5
 213      =1  
 214      =1  #define P16Port          P1
 215      =1  #define P16SHADOW        P1Shadow
 216      =1  #define P16DIR           P1DIR
 217      =1  #define P16SHADOWDIR     P1ShadowDIR
 218      =1  #define P16DIR_PAGE      P1DIR_PAGE
 219      =1  #define P16              6
 220      =1  
 221      =1  #define P17Port          P1
 222      =1  #define P17SHADOW        P1Shadow
 223      =1  #define P17DIR           P1DIR
 224      =1  #define P17SHADOWDIR     P1ShadowDIR
 225      =1  #define P17DIR_PAGE      P1DIR_PAGE
 226      =1  #define P17              7
 227      =1  
 228      =1  
 229      =1  #define P20Port          P2
 230      =1  #define P20SHADOW        P2Shadow
 231      =1  #define P20DIR           P2DIR
 232      =1  #define P20SHADOWDIR     P2ShadowDIR
 233      =1  #define P20DIR_PAGE      P2DIR_PAGE
 234      =1  #define P20              0
 235      =1  
 236      =1  #define P21Port          P2
 237      =1  #define P21SHADOW        P2Shadow
 238      =1  #define P21DIR           P2DIR
 239      =1  #define P21SHADOWDIR     P2ShadowDIR
 240      =1  #define P21DIR_PAGE      P2DIR_PAGE
 241      =1  #define P21              1
 242      =1  
 243      =1  #define P22Port          P2
 244      =1  #define P22SHADOW        P2Shadow
 245      =1  #define P22DIR           P2DIR
 246      =1  #define P22SHADOWDIR     P2ShadowDIR
 247      =1  #define P22DIR_PAGE      P2DIR_PAGE
 248      =1  #define P22              2
 249      =1  
 250      =1  #define P23Port          P2
 251      =1  #define P23SHADOW        P2Shadow
 252      =1  #define P23DIR           P2DIR
 253      =1  #define P23SHADOWDIR     P2ShadowDIR
 254      =1  #define P23DIR_PAGE      P2DIR_PAGE
 255      =1  #define P23              3
 256      =1  
 257      =1  #define P24Port          P2
 258      =1  #define P24SHADOW        P2Shadow
 259      =1  #define P24DIR           P2DIR
 260      =1  #define P24SHADOWDIR     P2ShadowDIR
 261      =1  #define P24DIR_PAGE      P2DIR_PAGE
 262      =1  #define P24              4
 263      =1  
 264      =1  #define P25Port          P2
 265      =1  #define P25SHADOW        P2Shadow
 266      =1  #define P25DIR           P2DIR
 267      =1  #define P25SHADOWDIR     P2ShadowDIR
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 8   

 268      =1  #define P25DIR_PAGE      P2DIR_PAGE
 269      =1  #define P25              5
 270      =1  
 271      =1  #define P26Port          P2
 272      =1  #define P26SHADOW        P2Shadow
 273      =1  #define P26DIR           P2DIR
 274      =1  #define P26SHADOWDIR     P2ShadowDIR
 275      =1  #define P26DIR_PAGE      P2DIR_PAGE
 276      =1  #define P26              6
 277      =1  
 278      =1  #define P27Port          P2
 279      =1  #define P27SHADOW        P2Shadow
 280      =1  #define P27DIR           P2DIR
 281      =1  #define P27SHADOWDIR     P2ShadowDIR
 282      =1  #define P27DIR_PAGE      P2DIR_PAGE
 283      =1  #define P27              7
 284      =1  
 285      =1  #define P30Port          P3
 286      =1  #define P30SHADOW        P3Shadow
 287      =1  #define P30DIR           P3DIR
 288      =1  #define P30SHADOWDIR     P3ShadowDIR
 289      =1  #define P30DIR_PAGE      P3DIR_PAGE
 290      =1  #define P30              0
 291      =1  
 292      =1  #define P31Port          P3
 293      =1  #define P31SHADOW        P3Shadow
 294      =1  #define P31DIR           P3DIR
 295      =1  #define P31SHADOWDIR     P3ShadowDIR
 296      =1  #define P31DIR_PAGE      P3DIR_PAGE
 297      =1  #define P31              1
 298      =1  
 299      =1  #define P34Port          P3
 300      =1  #define P34SHADOW        P3Shadow
 301      =1  #define P34DIR           P3DIR
 302      =1  #define P34SHADOWDIR     P3ShadowDIR
 303      =1  #define P34DIR_PAGE      P3DIR_PAGE
 304      =1  #define P34              4
 305      =1  
 306      =1  #define P35Port          P3
 307      =1  #define P35SHADOW        P3Shadow
 308      =1  #define P35DIR           P3DIR
 309      =1  #define P35SHADOWDIR     P3ShadowDIR
 310      =1  #define P35DIR_PAGE      P3DIR_PAGE
 311      =1  #define P35              5
 312      =1  
 313      =1  #define P36Port          P3
 314      =1  #define P36SHADOW        P3Shadow
 315      =1  #define P36DIR           P3DIR
 316      =1  #define P36SHADOWDIR     P3ShadowDIR
 317      =1  #define P36DIR_PAGE      P3DIR_PAGE
 318      =1  #define P36              6
 319      =1  
 320      =1  #define P37Port          P3
 321      =1  #define P37SHADOW        P3Shadow
 322      =1  #define P37DIR           P3DIR
 323      =1  #define P37SHADOWDIR     P3ShadowDIR
 324      =1  #define P37DIR_PAGE      P3DIR_PAGE
 325      =1  #define P37              7
 326      =1  
 327      =1  /* IO function definitions
 328      =1  ^(#define ^(*Port^)^( +P[0-9]^)^)
 329      =1  ^1 #define ^2SHADOW     ^3
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 9   

 330      =1  */
 331      =1  
 332      =1  /* Production Test Pin for Prod_Test_Dut, Pin 5 */
 333      =1  #define SSNPort          P0
 334      =1  #define SSNSHADOW        P0Shadow
 335      =1  #define SSNDIR           P0DIR
 336      =1  #define SSNSHADOWDIR     P0ShadowDIR
 337      =1  #define SSNDIR_PAGE      P0DIR_PAGE
 338      =1  #define SSN              4
 339      =1  
 340      =1  #define LED_OUT0Port          P0
 341      =1  #define LED_OUT0SHADOW        P0Shadow
 342      =1  #define LED_OUT0DIR           P0DIR
 343      =1  #define LED_OUT0SHADOWDIR     P0ShadowDIR
 344      =1  #define LED_OUT0DIR_PAGE      P0DIR_PAGE
 345      =1  #define LED_OUT0              4
 346      =1  
 347      =1  #define LED_OUT1Port          P0
 348      =1  #define LED_OUT1SHADOW        P0Shadow
 349      =1  #define LED_OUT1DIR           P0DIR
 350      =1  #define LED_OUT1SHADOWDIR     P0ShadowDIR
 351      =1  #define LED_OUT1DIR_PAGE      P0DIR_PAGE
 352      =1  #define LED_OUT1              5
 353      =1  
 354      =1  #define LED_OUT2Port          P0
 355      =1  #define LED_OUT2SHADOW        P0Shadow
 356      =1  #define LED_OUT2DIR           P0DIR
 357      =1  #define LED_OUT2SHADOWDIR     P0ShadowDIR
 358      =1  #define LED_OUT2DIR_PAGE      P0DIR_PAGE
 359      =1  #define LED_OUT2              6
 360      =1  
 361      =1  #define LED_OUT3Port          P0
 362      =1  #define LED_OUT3SHADOW        P0Shadow
 363      =1  #define LED_OUT3DIR           P0DIR
 364      =1  #define LED_OUT3SHADOWDIR     P0ShadowDIR
 365      =1  #define LED_OUT3DIR_PAGE      P0DIR_PAGE
 366      =1  #define LED_OUT3              7
 367      =1  
 368      =1  #define KP_OUT0Port          P0
 369      =1  #define KP_OUT0SHADOW        P0Shadow
 370      =1  #define KP_OUT0DIR           P0DIR
 371      =1  #define KP_OUT0SHADOWDIR     P0ShadowDIR
 372      =1  #define KP_OUT0DIR_PAGE      P0DIR_PAGE
 373      =1  #define KP_OUT0              0
 374      =1  
 375      =1  #define KP_OUT1Port          P0
 376      =1  #define KP_OUT1SHADOW        P0Shadow
 377      =1  #define KP_OUT1DIR           P0DIR
 378      =1  #define KP_OUT1SHADOWDIR     P0ShadowDIR
 379      =1  #define KP_OUT1DIR_PAGE      P0DIR_PAGE
 380      =1  #define KP_OUT1              1
 381      =1  
 382      =1  #define KP_OUT2Port          P0
 383      =1  #define KP_OUT2SHADOW        P0Shadow
 384      =1  #define KP_OUT2DIR           P0DIR
 385      =1  #define KP_OUT2SHADOWDIR     P0ShadowDIR
 386      =1  #define KP_OUT2DIR_PAGE      P0DIR_PAGE
 387      =1  #define KP_OUT2              2
 388      =1  
 389      =1  #define KP_OUT3Port          P0
 390      =1  #define KP_OUT3SHADOW        P0Shadow
 391      =1  #define KP_OUT3DIR           P0DIR
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 10  

 392      =1  #define KP_OUT3SHADOWDIR     P0ShadowDIR
 393      =1  #define KP_OUT3DIR_PAGE      P0DIR_PAGE
 394      =1  #define KP_OUT3              3
 395      =1  
 396      =1  #define KP_OUT4Port          P0
 397      =1  #define KP_OUT4SHADOW        P0Shadow
 398      =1  #define KP_OUT4DIR           P0DIR
 399      =1  #define KP_OUT4SHADOWDIR     P0ShadowDIR
 400      =1  #define KP_OUT4DIR_PAGE      P0DIR_PAGE
 401      =1  #define KP_OUT4              4
 402      =1  
 403      =1  #define KP_OUT5Port          P0
 404      =1  #define KP_OUT5SHADOW        P0Shadow
 405      =1  #define KP_OUT5DIR           P0DIR
 406      =1  #define KP_OUT5SHADOWDIR     P0ShadowDIR
 407      =1  #define KP_OUT5DIR_PAGE      P0DIR_PAGE
 408      =1  #define KP_OUT5              5
 409      =1  
 410      =1  #define KP_OUT6Port          P0
 411      =1  #define KP_OUT6SHADOW        P0Shadow
 412      =1  #define KP_OUT6DIR           P0DIR
 413      =1  #define KP_OUT6SHADOWDIR     P0ShadowDIR
 414      =1  #define KP_OUT6DIR_PAGE      P0DIR_PAGE
 415      =1  #define KP_OUT6              6
 416      =1  
 417      =1  #define KP_OUT7Port          P0
 418      =1  #define KP_OUT7SHADOW        P0Shadow
 419      =1  #define KP_OUT7DIR           P0DIR
 420      =1  #define KP_OUT7SHADOWDIR     P0ShadowDIR
 421      =1  #define KP_OUT7DIR_PAGE      P0DIR_PAGE
 422      =1  #define KP_OUT7              7
 423      =1  
 424      =1  #define KP_OUT8Port          P3
 425      =1  #define KP_OUT8SHADOW        P3Shadow
 426      =1  #define KP_OUT8DIR           P3DIR
 427      =1  #define KP_OUT8SHADOWDIR     P3ShadowDIR
 428      =1  #define KP_OUT8DIR_PAGE      P3DIR_PAGE
 429      =1  #define KP_OUT8              7
 430      =1  
 431      =1  #define KP_OUT9Port          P3
 432      =1  #define KP_OUT9SHADOW        P3Shadow
 433      =1  #define KP_OUT9DIR           P3DIR
 434      =1  #define KP_OUT9SHADOWDIR     P3ShadowDIR
 435      =1  #define KP_OUT9DIR_PAGE      P3DIR_PAGE
 436      =1  #define KP_OUT9              6
 437      =1  
 438      =1  #define KP_OUT10Port          P3
 439      =1  #define KP_OUT10SHADOW        P3Shadow
 440      =1  #define KP_OUT10DIR           P3DIR
 441      =1  #define KP_OUT10SHADOWDIR     P3ShadowDIR
 442      =1  #define KP_OUT10DIR_PAGE      P3DIR_PAGE
 443      =1  #define KP_OUT10              5
 444      =1  
 445      =1  #define KP_OUT11Port          P3
 446      =1  #define KP_OUT11SHADOW        P3Shadow
 447      =1  #define KP_OUT11DIR           P3DIR
 448      =1  #define KP_OUT11SHADOWDIR     P3ShadowDIR
 449      =1  #define KP_OUT11DIR_PAGE      P3DIR_PAGE
 450      =1  #define KP_OUT11              4
 451      =1  
 452      =1  #define KP_OUT12Port          P3
 453      =1  #define KP_OUT12SHADOW        P3Shadow
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 11  

 454      =1  #define KP_OUT12DIR           P3DIR
 455      =1  #define KP_OUT12SHADOWDIR     P3ShadowDIR
 456      =1  #define KP_OUT12DIR_PAGE      P3DIR_PAGE
 457      =1  #define KP_OUT12              1
 458      =1  
 459      =1  #define KP_OUT13Port          P3
 460      =1  #define KP_OUT13SHADOW        P3Shadow
 461      =1  #define KP_OUT13DIR           P3DIR
 462      =1  #define KP_OUT13SHADOWDIR     P3ShadowDIR
 463      =1  #define KP_OUT13DIR_PAGE      P3DIR_PAGE
 464      =1  #define KP_OUT13              0
 465      =1  
 466      =1  #define KP_OUT14Port          P2
 467      =1  #define KP_OUT14SHADOW        P2Shadow
 468      =1  #define KP_OUT14DIR           P2DIR
 469      =1  #define KP_OUT14SHADOWDIR     P2ShadowDIR
 470      =1  #define KP_OUT14DIR_PAGE      P2DIR_PAGE
 471      =1  #define KP_OUT14              1
 472      =1  
 473      =1  #define KP_OUT15Port          P2
 474      =1  #define KP_OUT15SHADOW        P2Shadow
 475      =1  #define KP_OUT15DIR           P2DIR
 476      =1  #define KP_OUT15SHADOWDIR     P2ShadowDIR
 477      =1  #define KP_OUT15DIR_PAGE      P2DIR_PAGE
 478      =1  #define KP_OUT15              0
 479      =1  
 480      =1  #define KP_IN0Port          P1
 481      =1  #define KP_IN0SHADOW        P1Shadow
 482      =1  #define KP_IN0DIR           P1DIR
 483      =1  #define KP_IN0SHADOWDIR     P1ShadowDIR
 484      =1  #define KP_IN0DIR_PAGE      P1DIR_PAGE
 485      =1  #define KP_IN0              0
 486      =1  
 487      =1  #define KP_IN1Port          P1
 488      =1  #define KP_IN1SHADOW        P1Shadow
 489      =1  #define KP_IN1DIR           P1DIR
 490      =1  #define KP_IN1SHADOWDIR     P1ShadowDIR
 491      =1  #define KP_IN1DIR_PAGE      P1DIR_PAGE
 492      =1  #define KP_IN1              1
 493      =1  
 494      =1  #define KP_IN2Port          P1
 495      =1  #define KP_IN2SHADOW        P1Shadow
 496      =1  #define KP_IN2DIR           P1DIR
 497      =1  #define KP_IN2SHADOWDIR     P1ShadowDIR
 498      =1  #define KP_IN2DIR_PAGE      P1DIR_PAGE
 499      =1  #define KP_IN2              2
 500      =1  
 501      =1  #define KP_IN3Port          P1
 502      =1  #define KP_IN3SHADOW        P1Shadow
 503      =1  #define KP_IN3DIR           P1DIR
 504      =1  #define KP_IN3SHADOWDIR     P1ShadowDIR
 505      =1  #define KP_IN3DIR_PAGE      P1DIR_PAGE
 506      =1  #define KP_IN3              3
 507      =1  
 508      =1  #define KP_IN4Port          P1
 509      =1  #define KP_IN4SHADOW        P1Shadow
 510      =1  #define KP_IN4DIR           P1DIR
 511      =1  #define KP_IN4SHADOWDIR     P1ShadowDIR
 512      =1  #define KP_IN4DIR_PAGE      P1DIR_PAGE
 513      =1  #define KP_IN4              4
 514      =1  
 515      =1  #define KP_IN5Port          P1
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 12  

 516      =1  #define KP_IN5SHADOW        P1Shadow
 517      =1  #define KP_IN5DIR           P1DIR
 518      =1  #define KP_IN5SHADOWDIR     P1ShadowDIR
 519      =1  #define KP_IN5DIR_PAGE      P1DIR_PAGE
 520      =1  #define KP_IN5              5
 521      =1  
 522      =1  #define KP_IN6Port          P1
 523      =1  #define KP_IN6SHADOW        P1Shadow
 524      =1  #define KP_IN6DIR           P1DIR
 525      =1  #define KP_IN6SHADOWDIR     P1ShadowDIR
 526      =1  #define KP_IN6DIR_PAGE      P1DIR_PAGE
 527      =1  #define KP_IN6              6
 528      =1  
 529      =1  #define KP_IN7Port          P1
 530      =1  #define KP_IN7SHADOW        P1Shadow
 531      =1  #define KP_IN7DIR           P1DIR
 532      =1  #define KP_IN7SHADOWDIR     P1ShadowDIR
 533      =1  #define KP_IN7DIR_PAGE      P1DIR_PAGE
 534      =1  #define KP_IN7              7
 535      =1  
 536      =1  #define INT0Port          P1
 537      =1  #define INT0SHADOW        P1Shadow
 538      =1  #define INT0DIR           P1DIR
 539      =1  #define INT0SHADOWDIR     P1ShadowDIR
 540      =1  #define INT0DIR_PAGE      P1DIR_PAGE
 541      =1  #define INT0              0
 542      =1  
 543      =1  #define INT1Port          P1
 544      =1  #define INT1SHADOW        P1Shadow
 545      =1  #define INT1DIR           P1DIR
 546      =1  #define INT1SHADOWDIR     P1ShadowDIR
 547      =1  #define INT1DIR_PAGE      P1DIR_PAGE
 548      =1  #define INT1              1
 549      =1  
 550      =1  #define INT2Port          P1
 551      =1  #define INT2SHADOW        P1Shadow
 552      =1  #define INT2DIR           P1DIR
 553      =1  #define INT2SHADOWDIR     P1ShadowDIR
 554      =1  #define INT2DIR_PAGE      P1DIR_PAGE
 555      =1  #define INT2              2
 556      =1  
 557      =1  #define INT3Port          P1
 558      =1  #define INT3SHADOW        P1Shadow
 559      =1  #define INT3DIR           P1DIR
 560      =1  #define INT3SHADOWDIR     P1ShadowDIR
 561      =1  #define INT3DIR_PAGE      P1DIR_PAGE
 562      =1  #define INT3              3
 563      =1  
 564      =1  #define INT4Port          P1
 565      =1  #define INT4SHADOW        P1Shadow
 566      =1  #define INT4DIR           P1DIR
 567      =1  #define INT4SHADOWDIR     P1ShadowDIR
 568      =1  #define INT4DIR_PAGE      P1DIR_PAGE
 569      =1  #define INT4              4
 570      =1  
 571      =1  #define INT5Port          P1
 572      =1  #define INT5SHADOW        P1Shadow
 573      =1  #define INT5DIR           P1DIR
 574      =1  #define INT5SHADOWDIR     P1ShadowDIR
 575      =1  #define INT5DIR_PAGE      P1DIR_PAGE
 576      =1  #define INT5              5
 577      =1  
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 13  

 578      =1  #define INT6Port          P1
 579      =1  #define INT6SHADOW        P1Shadow
 580      =1  #define INT6DIR           P1DIR
 581      =1  #define INT6SHADOWDIR     P1ShadowDIR
 582      =1  #define INT6DIR_PAGE      P1DIR_PAGE
 583      =1  #define INT6              6
 584      =1  
 585      =1  #define INT7Port          P1
 586      =1  #define INT7SHADOW        P1Shadow
 587      =1  #define INT7DIR           P1DIR
 588      =1  #define INT7SHADOWDIR     P1ShadowDIR
 589      =1  #define INT7DIR_PAGE      P1DIR_PAGE
 590      =1  #define INT7              7
 591      =1  
 592      =1  #define UART0_RXDPort          P2
 593      =1  #define UART0_RXDSHADOW        P2Shadow
 594      =1  #define UART0_RXDDIR           P2DIR
 595      =1  #define UART0_RXDSHADOWDIR     P2ShadowDIR
 596      =1  #define UART0_RXDDIR_PAGE      P2DIR_PAGE
 597      =1  #define UART0_RXD              0
 598      =1  
 599      =1  #define UART0_TXDPort          P2
 600      =1  #define UART0_TXDSHADOW        P2Shadow
 601      =1  #define UART0_TXDDIR           P2DIR
 602      =1  #define UART0_TXDSHADOWDIR     P2ShadowDIR
 603      =1  #define UART0_TXDDIR_PAGE      P2DIR_PAGE
 604      =1  #define UART0_TXD              1
 605      =1  
 606      =1  #define SPI1_MOSIPort          P2
 607      =1  #define SPI1_MOSISHADOW        P2Shadow
 608      =1  #define SPI1_MOSIDIR           P2DIR
 609      =1  #define SPI1_MOSISHADOWDIR     P2ShadowDIR
 610      =1  #define SPI1_MOSIDIR_PAGE      P2DIR_PAGE
 611      =1  #define SPI1_MOSI              2
 612      =1  
 613      =1  #define SPI1_MISOPort          P2
 614      =1  #define SPI1_MISOSHADOW        P2Shadow
 615      =1  #define SPI1_MISODIR           P2DIR
 616      =1  #define SPI1_MISOSHADOWDIR     P2ShadowDIR
 617      =1  #define SPI1_MISODIR_PAGE      P2DIR_PAGE
 618      =1  #define SPI1_MISO              3
 619      =1  
 620      =1  #define SPI1_SCKPort          P2
 621      =1  #define SPI1_SCKSHADOW        P2Shadow
 622      =1  #define SPI1_SCKDIR           P2DIR
 623      =1  #define SPI1_SCKSHADOWDIR     P2ShadowDIR
 624      =1  #define SPI1_SCKDIR_PAGE      P2DIR_PAGE
 625      =1  #define SPI1_SCK              4
 626      =1  
 627      =1  #define ISP_MISOPort          P2
 628      =1  #define ISP_MISOSHADOW        P2Shadow
 629      =1  #define ISP_MISODIR           P2DIR
 630      =1  #define ISP_MISOSHADOWDIR     P2ShadowDIR
 631      =1  #define ISP_MISODIR_PAGE      P2DIR_PAGE
 632      =1  #define ISP_MISO              2
 633      =1  
 634      =1  #define ISP_MOSIPort          P2
 635      =1  #define ISP_MOSISHADOW        P2Shadow
 636      =1  #define ISP_MOSIDIR           P2DIR
 637      =1  #define ISP_MOSISHADOWDIR     P2ShadowDIR
 638      =1  #define ISP_MOSIDIR_PAGE      P2DIR_PAGE
 639      =1  #define ISP_MOSI              3
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 14  

 640      =1  
 641      =1  #define ISP_SCKPort          P2
 642      =1  #define ISP_SCKSHADOW        P2Shadow
 643      =1  #define ISP_SCKDIR           P2DIR
 644      =1  #define ISP_SCKSHADOWDIR     P2ShadowDIR
 645      =1  #define ISP_SCKDIR_PAGE      P2DIR_PAGE
 646      =1  #define ISP_SCK              4
 647      =1  
 648      =1  #define IR_TX0Port          P3
 649      =1  #define IR_TX0SHADOW        P3Shadow
 650      =1  #define IR_TX0DIR           P3DIR
 651      =1  #define IR_TX0SHADOWDIR     P3ShadowDIR
 652      =1  #define IR_TX0DIR_PAGE      P3DIR_PAGE
 653      =1  #define IR_TX0              4
 654      =1  
 655      =1  #define IR_TX1Port          P3
 656      =1  #define IR_TX1SHADOW        P3Shadow
 657      =1  #define IR_TX1DIR           P3DIR
 658      =1  #define IR_TX1SHADOWDIR     P3ShadowDIR
 659      =1  #define IR_TX1DIR_PAGE      P3DIR_PAGE
 660      =1  #define IR_TX1              5
 661      =1  
 662      =1  #define IR_TX2Port          P3
 663      =1  #define IR_TX2SHADOW        P3Shadow
 664      =1  #define IR_TX2DIR           P3DIR
 665      =1  #define IR_TX2SHADOWDIR     P3ShadowDIR
 666      =1  #define IR_TX2DIR_PAGE      P3DIR_PAGE
 667      =1  #define IR_TX2              6
 668      =1  
 669      =1  #define ADC0Port          P3
 670      =1  #define ADC0SHADOW        P3Shadow
 671      =1  #define ADC0DIR           P3DIR
 672      =1  #define ADC0SHADOWDIR     P3ShadowDIR
 673      =1  #define ADC0DIR_PAGE      P3DIR_PAGE
 674      =1  #define ADC0              4
 675      =1  
 676      =1  #define ADC1Port          P3
 677      =1  #define ADC1SHADOW        P3Shadow
 678      =1  #define ADC1DIR           P3DIR
 679      =1  #define ADC1SHADOWDIR     P3ShadowDIR
 680      =1  #define ADC1DIR_PAGE      P3DIR_PAGE
 681      =1  #define ADC1              5
 682      =1  
 683      =1  #define ADC2Port          P3
 684      =1  #define ADC2SHADOW        P3Shadow
 685      =1  #define ADC2DIR           P3DIR
 686      =1  #define ADC2SHADOWDIR     P3ShadowDIR
 687      =1  #define ADC2DIR_PAGE      P3DIR_PAGE
 688      =1  #define ADC2              6
 689      =1  
 690      =1  #define ADC3Port          P3
 691      =1  #define ADC3SHADOW        P3Shadow
 692      =1  #define ADC3DIR           P3DIR
 693      =1  #define ADC3SHADOWDIR     P3ShadowDIR
 694      =1  #define ADC3DIR_PAGE      P3DIR_PAGE
 695      =1  #define ADC3              7
 696      =1  
 697      =1  #define UART1_TXDPort          P3
 698      =1  #define UART1_TXDSHADOW        P3Shadow
 699      =1  #define UART1_TXDDIR           P3DIR
 700      =1  #define UART1_TXDSHADOWDIR     P3ShadowDIR
 701      =1  #define UART1_TXDDIR_PAGE      P3DIR_PAGE
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 15  

 702      =1  #define UART1_TXD              1
 703      =1  
 704      =1  #define UART1_RXDPort          P3
 705      =1  #define UART1_RXDSHADOW        P3Shadow
 706      =1  #define UART1_RXDDIR           P3DIR
 707      =1  #define UART1_RXDSHADOWDIR     P3ShadowDIR
 708      =1  #define UART1_RXDDIR_PAGE      P3DIR_PAGE
 709      =1  #define UART1_RXD              0
 710      =1  
 711      =1  #define SPI0_SSNPort          P3
 712      =1  #define SPI0_SSNSHADOW        P3Shadow
 713      =1  #define SPI0_SSNDIR           P3DIR
 714      =1  #define SPI0_SSNSHADOWDIR     P3ShadowDIR
 715      =1  #define SPI0_SSNDIR_PAGE      P3DIR_PAGE
 716      =1  #define SPI0_SSN              0
 717      =1  
 718      =1  #define SPI0_MOSIPort          P2
 719      =1  #define SPI0_MOSISHADOW        P2Shadow
 720      =1  #define SPI0_MOSIDIR           P2DIR
 721      =1  #define SPI0_MOSISHADOWDIR     P2ShadowDIR
 722      =1  #define SPI0_MOSIDIR_PAGE      P2DIR_PAGE
 723      =1  #define SPI0_MOSI              5
 724      =1  
 725      =1  #define SPI0_MISOPort          P2
 726      =1  #define SPI0_MISOSHADOW        P2Shadow
 727      =1  #define SPI0_MISODIR           P2DIR
 728      =1  #define SPI0_MISOSHADOWDIR     P2ShadowDIR
 729      =1  #define SPI0_MISODIR_PAGE      P2DIR_PAGE
 730      =1  #define SPI0_MISO              6
 731      =1  
 732      =1  #define SPI0_SCKPort          P2
 733      =1  #define SPI0_SCKSHADOW        P2Shadow
 734      =1  #define SPI0_SCKDIR           P2DIR
 735      =1  #define SPI0_SCKSHADOWDIR     P2ShadowDIR
 736      =1  #define SPI0_SCKDIR_PAGE      P2DIR_PAGE
 737      =1  #define SPI0_SCK              7
 738      =1  
 739      =1  #define IR_RXPort          P3
 740      =1  #define IR_RXSHADOW        P3Shadow
 741      =1  #define IR_RXDIR           P3DIR
 742      =1  #define IR_RXSHADOWDIR     P3ShadowDIR
 743      =1  #define IR_RXDIR_PAGE      P3DIR_PAGE
 744      =1  #define IR_RX              1
 745      =1  
 746      =1  
 747      =1  #define FIREPort          P3
 748      =1  #define FIRESHADOW        P3Shadow
 749      =1  #define FIREDIR           P3DIR
 750      =1  #define FIRESHADOWDIR     P3ShadowDIR
 751      =1  #define FIREDIR_PAGE      P3DIR_PAGE
 752      =1  #define FIRE              6
 753      =1  
 754      =1  #define TRIACPort          P3
 755      =1  #define TRIACSHADOW        P3Shadow
 756      =1  #define TRIACDIR           P3DIR
 757      =1  #define TRIACSHADOWDIR     P3ShadowDIR
 758      =1  #define TRIACDIR_PAGE      P3DIR_PAGE
 759      =1  #define TRIAC              6
 760      =1  
 761      =1  #define GP_PWMPort          P3
 762      =1  #define GP_PWMSHADOW        P3Shadow
 763      =1  #define GP_PWMDIR           P3DIR
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 16  

 764      =1  #define GP_PWMSHADOWDIR     P3ShadowDIR
 765      =1  #define GP_PWMDIR_PAGE      P3DIR_PAGE
 766      =1  #define GP_PWM              7
 767      =1  
 768      =1  #define ZEROXPort          P3
 769      =1  #define ZEROXSHADOW        P3Shadow
 770      =1  #define ZEROXDIR           P3DIR
 771      =1  #define ZEROXSHADOWDIR     P3ShadowDIR
 772      =1  #define ZEROXDIR_PAGE      P3DIR_PAGE
 773      =1  #define ZEROX              7
 774      =1  
 775      =1  #define IR_PWMPort          P3
 776      =1  #define IR_PWMSHADOW        P3Shadow
 777      =1  #define IR_PWMDIR           P3DIR
 778      =1  #define IR_PWMSHADOWDIR     P3ShadowDIR
 779      =1  #define IR_PWMDIR_PAGE      P3DIR_PAGE
 780      =1  #define IR_PWM              7
 781      =1  
 782      =1  #endif /* #if defined (ZW040x) || defined(ZW050x) */
 783      =1  
 784      =1  #endif /* _ZW_PINDEFS_H_ */
 785      =1  
  29          #include <ZW_typedefs.h>
   1      =1  /*******************************  ZW_typedefs.h  *******************************
   2      =1   *           #######
   3      =1   *           ##  ##
   4      =1   *           #  ##    ####   #####    #####  ##  ##   #####
   5      =1   *             ##    ##  ##  ##  ##  ##      ##  ##  ##
   6      =1   *            ##  #  ######  ##  ##   ####   ##  ##   ####
   7      =1   *           ##  ##  ##      ##  ##      ##   #####      ##
   8      =1   *          #######   ####   ##  ##  #####       ##  #####
   9      =1   *                                           #####
  10      =1   *          Products that speak Z-Wave work together better
  11      =1   *
  12      =1   *              Copyright (c) 2008
  13      =1   *              Zensys A/S
  14      =1   *              Denmark
  15      =1   *
  16      =1   *              All Rights Reserved
  17      =1   *
  18      =1   *    This source file is subject to the terms and conditions of the
  19      =1   *    Zensys Software License Agreement which restricts the manner
  20      =1   *    in which it may be used.
  21      =1   *
  22      =1   *---------------------------------------------------------------------------
  23      =1   *
  24      =1   * Description: Module description
  25      =1   *
  26      =1   * Author:   Ivar Jeppesen
  27      =1   *
  28      =1   * Last Changed By:  $Author: efh $
  29      =1   * Revision:         $Revision: 29359 $
  30      =1   * Last Changed:     $Date: 2014-07-11 11:13:33 +0200 (fr, 11 jul 2014) $
  31      =1   *
  32      =1   ****************************************************************************/
  33      =1  #ifndef _ZW_TYPEDEFS_H_
  30          #include <ZW_uart_api.h>
   1      =1  /***************************************************************************
   2      =1  *
   3      =1  * Copyright (c) 2001-2012
   4      =1  * Sigma Designs, Inc.
   5      =1  * All Rights Reserved
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 17  

   6      =1  *
   7      =1  *---------------------------------------------------------------------------
   8      =1  *
   9      =1  * Description: Interface driver for the 500 Series Z-Wave Single Chip
  10      =1  *              built-in UART's
  11      =1  *
  12      =1  * Author:      Morten Vested Olesen and Jess Christensen
  13      =1  *
  14      =1  * Last Changed By:  $Author: jsi $
  15      =1  * Revision:         $Revision: 30544 $
  16      =1  * Last Changed:     $Date: 2015-01-09 14:18:09 +0100 (fr, 09 jan 2015) $
  17      =1  *
  18      =1  ****************************************************************************/
  19      =1  #ifndef _ZW_UART_API_H_
  20      =1  #define _ZW_UART_API_H_
  21      =1  
  22      =1  /***************************************************************************/
  23      =1  /*                              INCLUDE FILES                              */
  24      =1  /***************************************************************************/
  25      =1  #include <ZW_typedefs.h>
   1      =2  /*******************************  ZW_typedefs.h  *******************************
   2      =2   *           #######
   3      =2   *           ##  ##
   4      =2   *           #  ##    ####   #####    #####  ##  ##   #####
   5      =2   *             ##    ##  ##  ##  ##  ##      ##  ##  ##
   6      =2   *            ##  #  ######  ##  ##   ####   ##  ##   ####
   7      =2   *           ##  ##  ##      ##  ##      ##   #####      ##
   8      =2   *          #######   ####   ##  ##  #####       ##  #####
   9      =2   *                                           #####
  10      =2   *          Products that speak Z-Wave work together better
  11      =2   *
  12      =2   *              Copyright (c) 2008
  13      =2   *              Zensys A/S
  14      =2   *              Denmark
  15      =2   *
  16      =2   *              All Rights Reserved
  17      =2   *
  18      =2   *    This source file is subject to the terms and conditions of the
  19      =2   *    Zensys Software License Agreement which restricts the manner
  20      =2   *    in which it may be used.
  21      =2   *
  22      =2   *---------------------------------------------------------------------------
  23      =2   *
  24      =2   * Description: Module description
  25      =2   *
  26      =2   * Author:   Ivar Jeppesen
  27      =2   *
  28      =2   * Last Changed By:  $Author: efh $
  29      =2   * Revision:         $Revision: 29359 $
  30      =2   * Last Changed:     $Date: 2014-07-11 11:13:33 +0200 (fr, 11 jul 2014) $
  31      =2   *
  32      =2   ****************************************************************************/
  33      =2  #ifndef _ZW_TYPEDEFS_H_
  26      =1  
  27      =1  /****************************************************************************/
  28      =1  /*                     EXPORTED TYPES and DEFINITIONS                       */
  29      =1  /****************************************************************************/
  30      =1  
  31      =1  /* Macroes for debug output */
  32      =1  #define ZW_DEBUG_BAUD_RATE    1152
  33      =1  
  34      =1  #ifdef ZW_DEBUG
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 18  

  63      =1  #ifdef ZW_DEBUG_USB
  74      =1  #ifdef ZW_DEBUG_UART0
  83      =1  #define ZW_DEBUG_INIT(baud)
  84      =1  #define ZW_DEBUG_SEND_BYTE(bData)
  85      =1  #define ZW_DEBUG_SEND_NUM(bData)
  86      =1  #define ZW_DEBUG_SEND_WORD_NUM(bData)
  87      =1  #define ZW_DEBUG_SEND_NL()
  88      =1  #define ZW_DEBUG_SEND_STR(STR)
  89      =1  #define ZW_DEBUG_TX_STATUS()
  90      =1  #endif /* ZW_DEBUG_UART0*/
  91      =1  #endif /* ZW_DEBUG_USB */
  92      =1  #endif /* ZW_DEBUG */
  93      =1  
  94      =1  #define ZW_UART0_INIT(baud)        ZW_UART0_init(baud, TRUE, FALSE)
  95      =1  #define ZW_UART0_SEND_BYTE(bData)  ZW_UART0_tx_send_byte(bData)
  96      =1  #define ZW_UART0_SEND_NUM(bData)   ZW_UART0_tx_send_num(bData)
  97      =1  #define ZW_UART0_SEND_DEC(bData)   ZW_UART0_tx_send_dec(bData)
  98      =1  #define ZW_UART0_REC_STATUS        (ZW_UART0_rx_int_get())
  99      =1  #define ZW_UART0_REC_BYTE          (ZW_UART0_rx_data_wait_get())
 100      =1  #define ZW_UART0_SEND_NL()         ZW_UART0_tx_send_nl()
 101      =1  #define ZW_UART0_SEND_STATUS       (ZW_UART0_tx_active_get())
 102      =1  #define ZW_UART0_SEND_STR(STR)     (ZW_UART0_tx_send_str(STR))
 103      =1  
 104      =1  #define ZW_UART_INIT(baud)        ZW_UART1_init(baud, TRUE, FALSE)
 105      =1  #define ZW_UART_SEND_BYTE(bData)  ZW_UART1_tx_send_byte(bData)
 106      =1  #define ZW_UART_SEND_NUM(bData)   ZW_UART1_tx_send_num(bData)
 107      =1  #define ZW_UART_REC_STATUS        (ZW_UART1_rx_int_get())
 108      =1  #define ZW_UART_REC_BYTE          (ZW_UART1_rx_data_wait_get())
 109      =1  #define ZW_UART_SEND_NL()         ZW_UART1_tx_send_nl()
 110      =1  #define ZW_UART_SEND_STATUS       (ZW_UART1_tx_int_get())
 111      =1  #define ZW_UART_SEND_STR(STR)     (ZW_UART1_tx_send_str(STR))
 112      =1  
 113      =1  #define UART_RX_DMA_STATUS_LOD       0x80
 114      =1  #define UART_RX_DMA_STATUS_EOR       0x40
 115      =1  #define UART_RX_DMA_STATUS_BUFFULL   0x20
 116      =1  #define UART_RX_DMA_STATUS_RUNNING   0x10
 117      =1  #define UART_RX_DMA_STATUS_CURBUF1   0x02
 118      =1  
 119      =1  #define UART_RX_DMA_LOD_INT_EN       0x20
 120      =1  #define UART_RX_DMA_SWITCH_COUNT     0x08
 121      =1  #define UART_RX_DMA_SWITCH_FULL      0x04
 122      =1  #define UART_RX_DMA_SWITCH_EOR       0x01
 123      =1  
 124      =1  #define UART_TX_DMA_STATUS_SLOW_XRAM 0x80
 125      =1  #define UART_TX_DMA_STATUS_RUNNING   0x10
 126      =1  
 127      =1  /***************************************************************************/
 128      =1  /*                              EXPORTED DATA                              */
 129      =1  /***************************************************************************/
 130      =1  
 131      =1  /***************************************************************************/
 132      =1  /*                           EXPORTED FUNCTIONS                            */
 133      =1  /***************************************************************************/
 134      =1  
 135      =1  /*===============================   ZW_UART_init   =============================
 136      =1  **  Initializes UART0.
 137      =1  **  Optionally enables transmit and/or receive, clears the rx and tx interrupt
 138      =1  **  flags, and sets the specified baudrate.
 139      =1  **
 140      =1  **  Side effects:
 141      =1  **--------------------------------------------------------------------------*/
 142      =1  void             /*RET Nothing */
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 19  

 143      =1  ZW_UART_init(
 144      =1    WORD bBaudRate,  /* IN  Baud rate / 100 (e.g. 96 => 9600baud/s, 1152 => 115200baud/s) */
 145      =1    BYTE bEnableTx,  /* IN  TRUE: Tx enabled, FALSE: Tx disabled */
 146      =1    BYTE bEnableRx); /* IN  TRUE: Rx enabled, FALSE: Rx disabled */
 147      =1  
 148      =1  /*===============================   ZW_UART0_init   =============================
 149      =1  **  Initializes UART0.
 150      =1  **  Optionally enables transmit and/or receive, clears the rx and tx interrupt
 151      =1  **  flags, and sets the specified baudrate.
 152      =1  **
 153      =1  **  Side effects:
 154      =1  **--------------------------------------------------------------------------*/
 155      =1  void             /*RET Nothing */
 156      =1  ZW_UART0_init(
 157      =1    WORD bBaudRate,  /* IN  Baud rate / 100 (e.g. 96 => 9600baud/s, 1152 => 115200baud/s) */
 158      =1    BYTE bEnableTx,  /* IN  TRUE: Tx enabled, FALSE: Tx disabled */
 159      =1    BYTE bEnableRx); /* IN  TRUE: Rx enabled, FALSE: Rx disabled */
 160      =1  
 161      =1  /*==============================   ZW_UART0_INT_ENABLE  =============================
 162      =1  **  Enables UART0 interrupt
 163      =1  **
 164      =1  **    Side effects:
 165      =1  **--------------------------------------------------------------------------*/
 166      =1  
 167      =1  #define ZW_UART0_INT_ENABLE  ES0=1
 168      =1  
 169      =1  /*==============================   ZW_UART0_INT_DISABLE  =============================
 170      =1  **  Disables UART0 interrupt
 171      =1  **
 172      =1  **    Side effects:
 173      =1  **--------------------------------------------------------------------------*/
 174      =1  
 175      =1  #define ZW_UART0_INT_DISABLE ES0=0
 176      =1  
 177      =1  /*===============================   ZW_UART_tx_send_byte   ========================
 178      =1  **  Wait until UART0 Tx is idle, then write data byte to UART0 transmit register
 179      =1  **
 180      =1  **    Side effects: waits until UART0 Tx is idle
 181      =1  **--------------------------------------------------------------------------*/
 182      =1  void
 183      =1  ZW_UART_tx_send_byte(
 184      =1    BYTE bData);  /* IN a byte to written to the UART transmit register.*/
 185      =1  
 186      =1  /*===========================  ZW_UART_tx_send_dec  ==========================
 187      =1  **  Converts a byte to a two-digit decimal ASCII representation,
 188      =1  **  and transmits it over UART0.
 189      =1  **
 190      =1  **    Side effects:
 191      =1  **
 192      =1  **--------------------------------------------------------------------------*/
 193      =1  void            /*RET Nothing */
 194      =1  ZW_UART_tx_send_dec(
 195      =1    BYTE bData);  /* IN data to send */
 196      =1  
 197      =1  /*===========================  ZW_UART_tx_send_hex  ==========================
 198      =1  **  Converts a byte to a two-byte hexadecimal ASCII representation,
 199      =1  **  and transmits it over UART0.
 200      =1  **
 201      =1  **    Side effects:
 202      =1  **
 203      =1  **--------------------------------------------------------------------------*/
 204      =1  #define ZW_UART_tx_send_num ZW_UART_tx_send_hex
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 20  

 205      =1  
 206      =1  void            /*RET Nothing */
 207      =1  ZW_UART_tx_send_hex(
 208      =1    BYTE bData);   /* IN data to send */
 209      =1  
 210      =1  
 211      =1  /*===========================  ZW_UART_tx_send_w_num  ==========================
 212      =1  **  Converts a WORD to a 4-byte hexadecimal ASCII representation,
 213      =1  **  and transmits it over UART0.
 214      =1  **
 215      =1  **    Side effects:
 216      =1  **
 217      =1  **--------------------------------------------------------------------------*/
 218      =1  void            /*RET Nothing */
 219      =1  ZW_UART_tx_send_w_num(
 220      =1    WORD bData);   /* IN data to send */
 221      =1  
 222      =1  /*============================   ZW_UART_tx_send_str   ========================
 223      =1  **  Transmit a null terminated string over UART0.
 224      =1  **  The null data is not transmitted.
 225      =1  **
 226      =1  **    Side effects:
 227      =1  **
 228      =1  **--------------------------------------------------------------------------*/
 229      =1  void          /*RET Nothing */
 230      =1  ZW_UART_tx_send_str(
 231      =1    BYTE_P str); /* IN String pointer */
 232      =1  
 233      =1  /*=============================   ZW_UART_send_nl   =========================
 234      =1  **  Transmit CR + LF over UART0.
 235      =1  **
 236      =1  **    Side effects:
 237      =1  **
 238      =1  **--------------------------------------------------------------------------*/
 239      =1  void                /*RET Nothing */
 240      =1  ZW_UART_tx_send_nl( void ); /*IN Nothing */
 241      =1  
 242      =1  /*===============================   ZW_UART_tx_active_get   ========================
 243      =1  **  This function checks if the UART0 is sending.
 244      =1  **
 245      =1  **    Side effects:
 246      =1  **--------------------------------------------------------------------------*/
 247      =1  
 248      =1  BYTE    /* RET zero (0x00): UART0 tx is idle,
 249      =1           *     non-zero:  : UART0 tx is active     */
 250      =1  ZW_UART_tx_active_get(void);
 251      =1  
 252      =1  
 253      =1  /*===============================   ZW_UART0_rx_int_clear   ========================
 254      =1  **  Clear the UART0 Rx interrupt flag
 255      =1  **
 256      =1  **    Side effects:
 257      =1  **--------------------------------------------------------------------------*/
 258      =1  void
 259      =1  ZW_UART0_rx_int_clear(void);
 260      =1  
 261      =1  /*=============================   ZW_UART0_tx_int_clear   ========================
 262      =1  **  Clear the UART0 Tx interrupt flag
 263      =1  **
 264      =1  **    Side effects:
 265      =1  **--------------------------------------------------------------------------*/
 266      =1  void
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 21  

 267      =1  ZW_UART0_tx_int_clear(void);
 268      =1  
 269      =1  /*===============================   ZW_UART0_rx_data_wait_get   ========================
 270      =1  **  Read the content of the UART0 receive register
 271      =1  **
 272      =1  **    Side effects:
 273      =1  **--------------------------------------------------------------------------*/
 274      =1  BYTE    /* RET the content of the receive register*/
 275      =1  ZW_UART0_rx_data_wait_get(void);
 276      =1  
 277      =1  /*===============================   ZW_UART0_rx_data_get   ========================
 278      =1  **  Read the content of the UART0 receive register
 279      =1  **
 280      =1  **    Side effects:
 281      =1  **--------------------------------------------------------------------------*/
 282      =1  
 283      =1  BYTE    /* RET the content of the receive register*/
 284      =1  ZW_UART0_rx_data_get(void);
 285      =1  
 286      =1  /*===============================   ZW_UART0_tx_data_set   ========================
 287      =1  **  Write data byte to UART0 transmit register
 288      =1  **
 289      =1  **    Side effects:
 290      =1  **--------------------------------------------------------------------------*/
 291      =1  void
 292      =1  ZW_UART0_tx_data_set(
 293      =1    BYTE txByte);  /* IN a byte to written to the UART transmit register.*/
 294      =1  
 295      =1  /*===============================   ZW_UART0_tx_send_byte   ========================
 296      =1  **  Wait until UART0 Tx is idle, then write data byte to UART0 transmit register
 297      =1  **
 298      =1  **    Side effects: waits until UART0 Tx is idle
 299      =1  **--------------------------------------------------------------------------*/
 300      =1  void
 301      =1  ZW_UART0_tx_send_byte(
 302      =1    BYTE bData);  /* IN a byte to written to the UART transmit register.*/
 303      =1  
 304      =1  /*===============================   ZW_UART0_rx_enable   ========================
 305      =1  **  Enable the UART receiver and reserve IO.
 306      =1  **
 307      =1  **    Side effects:
 308      =1  **--------------------------------------------------------------------------*/
 309      =1  void
 310      =1  ZW_UART0_rx_enable(
 311      =1    BYTE bState); /* IN  TRUE: enables UART0 rx function, FALSE: disables UART0 rx function */
 312      =1  
 313      =1  /*===============================   ZW_UART0_tx_enable   ========================
 314      =1  **  Enable the UART transmitter and reserve IO.
 315      =1  **
 316      =1  **    Side effects:
 317      =1  **--------------------------------------------------------------------------*/
 318      =1  void
 319      =1  ZW_UART0_tx_enable(
 320      =1    BYTE bState); /* IN  TRUE: enables UART0 tx function, FALSE: disables UART0 tx function */
 321      =1  
 322      =1  
 323      =1  /*===============================   ZW_UART0_tx_int_get   ========================
 324      =1  **  This function checks if the UART0 has sent a byte.
 325      =1  **
 326      =1  **    Side effects:
 327      =1  **--------------------------------------------------------------------------*/
 328      =1  
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 22  

 329      =1  BYTE    /* RET zero (0x00): tx interrupt flag is not set,
 330      =1           *     non-zero:  : tx interrupt flag is set      */
 331      =1  ZW_UART0_tx_int_get(void);
 332      =1  
 333      =1  /*===============================   ZW_UART0_tx_active_get   ========================
 334      =1  **  This function checks if the UART0 is sending.
 335      =1  **
 336      =1  **    Side effects:
 337      =1  **--------------------------------------------------------------------------*/
 338      =1  
 339      =1  BYTE    /* RET zero (0x00): UART0 tx is idle,
 340      =1           *     non-zero:  : UART0 tx is active     */
 341      =1  ZW_UART0_tx_active_get(void);
 342      =1  
 343      =1  /*===============================   ZW_UART0_rx_int_get   ========================
 344      =1  **  This function checks if the UART0 has received a byte.
 345      =1  **
 346      =1  **    Side effects:
 347      =1  **--------------------------------------------------------------------------*/
 348      =1  BYTE    /* RET zero (0x00): rx interrupt flag is not set,
 349      =1           *     non-zero:  : rx interrupt flag is set      */
 350      =1  ZW_UART0_rx_int_get(void);
 351      =1  
 352      =1  
 353      =1  /*===========================  ZW_UART0_tx_send_dec  ==========================
 354      =1  **  Converts a byte to a two-digit decimal ASCII representation,
 355      =1  **  and transmits it over UART0.
 356      =1  **
 357      =1  **    Side effects:
 358      =1  **
 359      =1  **--------------------------------------------------------------------------*/
 360      =1  void            /*RET Nothing */
 361      =1  ZW_UART0_tx_send_dec(
 362      =1    BYTE bData);  /* IN data to send */
 363      =1  
 364      =1  /*===========================  ZW_UART0_tx_send_hex  ==========================
 365      =1  **  Converts a byte to a two-byte hexadecimal ASCII representation,
 366      =1  **  and transmits it over UART0.
 367      =1  **
 368      =1  **    Side effects:
 369      =1  **
 370      =1  **--------------------------------------------------------------------------*/
 371      =1  #define ZW_UART0_tx_send_num ZW_UART0_tx_send_hex
 372      =1  
 373      =1  void            /*RET Nothing */
 374      =1  ZW_UART0_tx_send_hex(
 375      =1    BYTE bData);   /* IN data to send */
 376      =1  
 377      =1  
 378      =1  /*===========================  ZW_UART0_tx_send_w_num  ==========================
 379      =1  **  Converts a WORD to a 4-byte hexadecimal ASCII representation,
 380      =1  **  and transmits it over UART0.
 381      =1  **
 382      =1  **    Side effects:
 383      =1  **
 384      =1  **--------------------------------------------------------------------------*/
 385      =1  void            /*RET Nothing */
 386      =1  ZW_UART0_tx_send_w_num(
 387      =1    WORD bData);   /* IN data to send */
 388      =1  
 389      =1  /*============================   ZW_UART0_tx_send_str   ========================
 390      =1  **  Transmit a null terminated string over UART0.
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 23  

 391      =1  **  The null data is not transmitted.
 392      =1  **
 393      =1  **    Side effects:
 394      =1  **
 395      =1  **--------------------------------------------------------------------------*/
 396      =1  void          /*RET Nothing */
 397      =1  ZW_UART0_tx_send_str(
 398      =1    BYTE_P str); /* IN String pointer */
 399      =1  
 400      =1  /*=============================   ZW_UART0_send_nl   =========================
 401      =1  **  Transmit CR + LF over UART0.
 402      =1  **
 403      =1  **    Side effects:
 404      =1  **
 405      =1  **--------------------------------------------------------------------------*/
 406      =1  void                /*RET Nothing */
 407      =1  ZW_UART0_tx_send_nl( void ); /*IN Nothing */
 408      =1  
 409      =1  
 410      =1  /*===============================   ZW_UART1_init   =============================
 411      =1  **  Initializes UART1.
 412      =1  **  Optionally enables transmit and/or receive, clears the rx and tx interrupt
 413      =1  **  flags, and sets the specified baudrate.
 414      =1  **
 415      =1  **  Side effects:
 416      =1  **--------------------------------------------------------------------------*/
 417      =1  void             /*RET Nothing */
 418      =1  ZW_UART1_init(
 419      =1    WORD bBaudRate,  /* IN  Baud rate / 100 (e.g. 96 => 9600baud/s, 1152 => 115200baud/s) */
 420      =1    BYTE bEnableTx,  /* IN  TRUE: Tx enabled, FALSE: Tx disabled */
 421      =1    BYTE bEnableRx); /* IN  TRUE: Rx enabled, FALSE: Rx disabled */
 422      =1  
 423      =1  /*==============================   ZW_UART1_INT_ENABLE  =============================
 424      =1  **  Enables UART0 interrupt
 425      =1  **
 426      =1  **    Side effects:
 427      =1  **--------------------------------------------------------------------------*/
 428      =1  
 429      =1  #define ZW_UART1_INT_ENABLE  ES1=1
 430      =1  
 431      =1  /*==============================   ZW_UART1_INT_DISABLE  =============================
 432      =1  **  Disables UART0 interrupt
 433      =1  **
 434      =1  **    Side effects:
 435      =1  **--------------------------------------------------------------------------*/
 436      =1  
 437      =1  #define ZW_UART1_INT_DISABLE ES1=0
 438      =1  
 439      =1  /*===============================   ZW_UART1_rx_int_clear   ========================
 440      =1  **  Clear the UART1 Rx interrupt flag
 441      =1  **
 442      =1  **    Side effects:
 443      =1  **--------------------------------------------------------------------------*/
 444      =1  void
 445      =1  ZW_UART1_rx_int_clear(void);
 446      =1  
 447      =1  /*=============================   ZW_UART1_tx_int_clear   ========================
 448      =1  **  Clear the UART1 Tx interrupt flag
 449      =1  **
 450      =1  **    Side effects:
 451      =1  **--------------------------------------------------------------------------*/
 452      =1  void
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 24  

 453      =1  ZW_UART1_tx_int_clear(void);
 454      =1  
 455      =1  /*===============================   ZW_UART1_rx_data_wait_get   ========================
 456      =1  **  Read the content of the UART1 receive register
 457      =1  **
 458      =1  **    Side effects:
 459      =1  **--------------------------------------------------------------------------*/
 460      =1  BYTE    /* RET the content of the receive register*/
 461      =1  ZW_UART1_rx_data_wait_get(void);
 462      =1  
 463      =1  /*===============================   ZW_UART1_rx_data_get   ========================
 464      =1  **  Read the content of the UART1 receive register
 465      =1  **
 466      =1  **    Side effects:
 467      =1  **--------------------------------------------------------------------------*/
 468      =1  
 469      =1  BYTE    /* RET the content of the receive register*/
 470      =1  ZW_UART1_rx_data_get(void);
 471      =1  
 472      =1  /*===============================   ZW_UART1_tx_data_set   ========================
 473      =1  **  Write data byte to UART1 transmit register
 474      =1  **
 475      =1  **    Side effects:
 476      =1  **--------------------------------------------------------------------------*/
 477      =1  void
 478      =1  ZW_UART1_tx_data_set(
 479      =1    BYTE txByte);  /* IN a byte to written to the UART transmit register.*/
 480      =1  
 481      =1  /*===============================   ZW_UART1_tx_send_byte   ========================
 482      =1  **  Wait until UART1 Tx is idle, then write data byte to UART1 transmit register
 483      =1  **
 484      =1  **    Side effects: waits until UART1 Tx is idle
 485      =1  **--------------------------------------------------------------------------*/
 486      =1  void
 487      =1  ZW_UART1_tx_send_byte(
 488      =1    BYTE bData);  /* IN a byte to written to the UART transmit register.*/
 489      =1  
 490      =1  /*===============================   ZW_UART1_rx_enable   ========================
 491      =1  **  Enable the UART receiver and reserve IO.
 492      =1  **
 493      =1  **    Side effects:
 494      =1  **--------------------------------------------------------------------------*/
 495      =1  void
 496      =1  ZW_UART1_rx_enable(
 497      =1    BYTE bState); /* IN  TRUE: enables UART1 rx function, FALSE: disables UART1 rx function */
 498      =1  
 499      =1  /*===============================   ZW_UART1_tx_enable   ========================
 500      =1  **  Enable the UART transmitter and reserve IO.
 501      =1  **
 502      =1  **    Side effects:
 503      =1  **--------------------------------------------------------------------------*/
 504      =1  void
 505      =1  ZW_UART1_tx_enable(
 506      =1    BYTE bState); /* IN  TRUE: enables UART1 tx function, FALSE: disables UART1 tx function */
 507      =1  
 508      =1  
 509      =1  /*===============================   ZW_UART1_tx_int_get   ========================
 510      =1  **  This function checks if the UART1 has sent a byte.
 511      =1  **
 512      =1  **    Side effects:
 513      =1  **--------------------------------------------------------------------------*/
 514      =1  
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 25  

 515      =1  BYTE    /* RET zero (0x00): tx interrupt flag is not set,
 516      =1           *     non-zero:  : tx interrupt flag is set      */
 517      =1  ZW_UART1_tx_int_get(void);
 518      =1  
 519      =1  /*===============================   ZW_UART1_tx_active_get   ========================
 520      =1  **  This function checks if the UART1 is sending.
 521      =1  **
 522      =1  **    Side effects:
 523      =1  **--------------------------------------------------------------------------*/
 524      =1  
 525      =1  BYTE    /* RET zero (0x00): UART1 tx is idle,
 526      =1           *     non-zero:  : UART1 tx is active     */
 527      =1  ZW_UART1_tx_active_get(void);
 528      =1  
 529      =1  
 530      =1  /*===============================   ZW_UART1_rx_int_get   ========================
 531      =1  **  This function checks if the UART1 has received a byte.
 532      =1  **
 533      =1  **    Side effects:
 534      =1  **--------------------------------------------------------------------------*/
 535      =1  BYTE    /* RET zero (0x00): rx interrupt flag is not set,
 536      =1           *     non-zero:  : rx interrupt flag is set      */
 537      =1  ZW_UART1_rx_int_get(void);
 538      =1  
 539      =1  
 540      =1  /*===========================  ZW_UART1_tx_send_num  ==========================
 541      =1  **  Converts a byte to a two-byte hexadecimal ASCII representation,
 542      =1  **  and transmits it over UART1.
 543      =1  **
 544      =1  **
 545      =1  **    Side effects:
 546      =1  **
 547      =1  **--------------------------------------------------------------------------*/
 548      =1  #define ZW_UART1_tx_send_num ZW_UART1_tx_send_hex
 549      =1  
 550      =1  void            /*RET Nothing */
 551      =1  ZW_UART1_tx_send_hex(BYTE bData);   /* IN data to send */
 552      =1  
 553      =1  /*===========================  ZW_UART1_tx_send_num  ==========================
 554      =1  **  Converts a WORD to a 4-byte hexadecimal ASCII representation,
 555      =1  **  and transmits it over UART1.
 556      =1  **
 557      =1  **    Side effects:
 558      =1  **
 559      =1  **--------------------------------------------------------------------------*/
 560      =1  void            /*RET Nothing */
 561      =1  ZW_UART1_tx_send_w_num(
 562      =1    WORD bData);   /* IN data to send */
 563      =1  
 564      =1  /*============================   ZW_UART1_tx_send_str   ========================
 565      =1  **  Transmit a null terminated string over UART1.
 566      =1  **  The null data is not transmitted.
 567      =1  **
 568      =1  **    Side effects:
 569      =1  **
 570      =1  **--------------------------------------------------------------------------*/
 571      =1  void          /*RET Nothing */
 572      =1  ZW_UART1_tx_send_str(BYTE_P str); /* IN String pointer */
 573      =1  
 574      =1  /*=============================   ZW_UART1_send_nl   =========================
 575      =1  **  Transmit CR + LF over UART1.
 576      =1  **
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 26  

 577      =1  **    Side effects:
 578      =1  **
 579      =1  **--------------------------------------------------------------------------*/
 580      =1  void                /*RET Nothing */
 581      =1  ZW_UART1_tx_send_nl( void ); /*IN Nothing */
 582      =1  
 583      =1  
 584      =1  /*--------------------------------------------------------------------------
 585      =1  **--------------------------------------------------------------------------
 586      =1  **
 587      =1  **  WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING
 588      =1  
 589      =1  ** The following API calls are obsolete and should NOT be used.
 590      =1  ** The API calls will be removed in a later developers kit release.
 591      =1  **
 592      =1  **--------------------------------------------------------------------------
 593      =1  **--------------------------------------------------------------------------*/
 594      =1  
 595      =1  /*===============================   ZW_UART0_tx_dma_int_byte_count  ========================
 596      =1  **  Set interrupt tx byte count
 597      =1  **
 598      =1  **  Parameters
 599      =1  **
 600      =1  **   bByteCount: IN Interrupt is issued when this number of bytes has been DMA'ed to the UART
 601      =1  **                    Disabled when set to 0x00 which is default after reset
 602      =1  **   Side effects:
 603      =1  **--------------------------------------------------------------------------*/
 604      =1  void                    /*RET Nothing */
 605      =1  ZW_UART0_tx_dma_int_byte_count( BYTE bByteCount);   /*IN Number of tx'ed bytes */
 606      =1  
 607      =1  /*===============================   ZW_UART0_tx_dma_inter_byte_delay  ========================
 608      =1  **  Set Tx inter byte delay
 609      =1  **  Parameters
 610      =1  **
 611      =1  **   bDelay:   IN Sets the inter byte delay 0x00 no delay (default after reset)
 612      =1  **                                          0x01  125ns delay
 613      =1  **                                          0x02  250ns delay
 614      =1  **                                                 :
 615      =1  **                                          0x0F 1875ns delay
 616      =1  **   Side effects:
 617      =1  **--------------------------------------------------------------------------*/
 618      =1  void                    /*RET Nothing */
 619      =1  ZW_UART0_tx_dma_inter_byte_delay( BYTE bDelay);   /*IN inter byte delay */
 620      =1  
 621      =1  /*===============================   ZW_UART0_tx_dma_data  ========================
 622      =1  **  Set buffer address and length and then start UART0 DMA
 623      =1  **  Parameters
 624      =1  **
 625      =1  **   pbAddress:  IN pointer to Tx buffer in lower 4kB XRAM
 626      =1  **   bBufferLen: IN length of Tx buffer in bytes
 627      =1  **
 628      =1  **   Side effects:
 629      =1  **       Discards any ongoing UART TX DMA process
 630      =1  **--------------------------------------------------------------------------*/
 631      =1  void                    /*RET Nothing */
 632      =1  ZW_UART0_tx_dma_data( XBYTE *pbAddress,    /*IN buffer base address */
 633      =1                        BYTE bBufferLen); /*IN buffer len */
 634      =1  
 635      =1  /*===============================   ZW_UART0_tx_dma_status  ========================
 636      =1  **  If the UART0 DMA process is ongoing this function Returns the status of this ongoing
 637      =1  **  process. Returns the status of the latest UART0 DMA process if the DMA has stopped.
 638      =1  **
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 27  

 639      =1  **  Returned values:
 640      =1  **       UART_TX_DMA_STATUS_SLOW_XRAM: DMA can not keep up with configured inter byte
 641      =1  **                                     process because of congestion in XRAM access
 642      =1  **       UART_TX_DMA_STATUS_RUNNING:   The DMA is transferring data to UART0
 643      =1  **
 644      =1  **  Parameters: None
 645      =1  **
 646      =1  **   Side effects:
 647      =1  **--------------------------------------------------------------------------*/
 648      =1  BYTE                    /*RET status */
 649      =1  ZW_UART0_tx_dma_status(void); /*IN Nothing */
 650      =1  
 651      =1  /*===============================   ZW_UART0_tx_dma_bytes_transferred  ========================
 652      =1  **  Returns the number of bytes that has been transferred to UART0 from XRAM for the ongoing DMA
 653      =1  **  process. If no transfer is ongoing the number of bytes that has been transferred to UART0
 654      =1  **  from XRAM from the latest process is returned.
 655      =1  **
 656      =1  **  Parameters: None
 657      =1  **
 658      =1  **   Side effects:
 659      =1  **--------------------------------------------------------------------------*/
 660      =1  BYTE                    /*RET bytes transferred */
 661      =1  ZW_UART0_tx_dma_bytes_transferred(void); /*IN Nothing */
 662      =1  
 663      =1  /*===============================   ZW_UART0_tx_dma_cancel  ========================
 664      =1  **  Cancels any ongoing DMA process and brings UART TX DMA to idle state
 665      =1  **
 666      =1  **  Parameters: None
 667      =1  **
 668      =1  **   Side effects:
 669      =1  **--------------------------------------------------------------------------*/
 670      =1  void                    /*RET nothing */
 671      =1  ZW_UART0_tx_dma_cancel(void); /*IN Nothing */
 672      =1  
 673      =1  
 674      =1  
 675      =1  /*===============================   ZW_UART0_rx_dma_init  ===============================
 676      =1  **  Initialize the buffers and setup for the UART0 Rx DMA
 677      =1  **
 678      =1  **  Parameters
 679      =1  **     pbAddress:  IN pointer to the base address of the two Rx buffers
 680      =1  **     bBufLength: IN length of UART0 RX Buffer - must be greater than 0
 681      =1  **     bBitMask:   IN bit mask contains the setting of the Rx DMA
 682      =1  **                      UART_RX_DMA_LOD_INT_EN    Enable Loss Of Data interrupt
 683      =1  **                      UART_RX_DMA_SWITCH_COUNT  Switch buffer when byte count is reached
 684      =1  **                      UART_RX_DMA_SWITCH_FULL   Switch buffer when buffer full
 685      =1  **                      UART_RX_DMA_SWITCH_EOR    Switch buffer when EOR is received
 686      =1  **
 687      =1  **    Side effects:
 688      =1  **       Discards any ongoing UART RX DMA process
 689      =1  **       Clears status information
 690      =1  **-------------------------------------------------------------------------------------*/
 691      =1  void                    /*RET Nothing */
 692      =1  ZW_UART0_rx_dma_init( XBYTE *pbAddress,   /* IN pointer to base address of RX buffers */
 693      =1                        BYTE bBufLength, /* IN byte length of each of the two buffers*/
 694      =1                        BYTE bBitMask);  /* IN see above */
 695      =1  
 696      =1  /*===============================   ZW_UART0_rx_dma_int_byte_count  ===============================
 697      =1  **  Set interrupt rx byte count. A value of 0x00 means disabled
 698      =1  **
 699      =1  **   bByteCount: IN Interrupt is issued when this number of bytes has been DMA'ed from the UART
 700      =1  **                  Disabled when set to 0x00
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 28  

 701      =1  **    Side effects:
 702      =1  **-------------------------------------------------------------------------------------*/
 703      =1  void                    /*RET Nothing */
 704      =1  ZW_UART0_rx_dma_int_byte_count(BYTE bByteCount); /*IN */
 705      =1  
 706      =1  
 707      =1  /*===============================   ZW_UART0_rx_dma_status  ========================
 708      =1  **  If the UART0 RX DMA process is ongoing this function returns the status of this ongoing
 709      =1  **  process. Returns the status of the latest UART0 RX DMA process if the DMA has stopped.
 710      =1  **
 711      =1  **  Returned values:
 712      =1  **       UART_RX_DMA_STATUS_EOR:     The DMA switched RX buffer because it has
 713      =1  **                                   recieved an End of Record char
 714      =1  **       UART_RX_DMA_STATUS_LOD:     DMA can not keep up with the speed of the incomming data
 715      =1  **       UART_RX_DMA_STATUS_CURBUF1: Set when the UART0 RX DMA currently is transferring data
 716      =1  **                                   from buffer 1. When cleared the UART0 RX DMA currently is
 717      =1  **                                   transferring data from buffer 0
 718      =1  **       UART_RX_DMA_STATUS_BUFFULL: Set when a buffer has been filled to the limit
 719      =1  **       UART_RX_DMA_STATUS_RUNNING: The DMA is enabled
 720      =1  **
 721      =1  **  Parameters: None
 722      =1  **
 723      =1  **   Side effects:
 724      =1  **--------------------------------------------------------------------------*/
 725      =1  BYTE                    /*RET status */
 726      =1  ZW_UART0_rx_dma_status(void); /*IN Nothing */
 727      =1  
 728      =1  /*===============================   ZW_UART0_rx_dma_bytes_transferred  ========================
 729      =1  **  Returns the number of bytes that has been transferred to UART0 to XRAM for the ongoing DMA
 730      =1  **  process.
 731      =1  **
 732      =1  **  Parameters: None
 733      =1  **
 734      =1  **   Side effects:
 735      =1  **--------------------------------------------------------------------------*/
 736      =1  BYTE                    /*RET bytes transferred */
 737      =1  ZW_UART0_rx_dma_bytes_transferred(void); /*IN Nothing */
 738      =1  
 739      =1  /*===============================   ZW_UART0_rx_dma_cancel  ========================
 740      =1  **  Cancels any ongoing DMA process and brings UART RX DMA to idle state
 741      =1  **
 742      =1  **  Parameters: None
 743      =1  **
 744      =1  **   Side effects:
 745      =1  **--------------------------------------------------------------------------*/
 746      =1  void                    /*RET nothing */
 747      =1  ZW_UART0_rx_dma_cancel(void); /*IN Nothing */
 748      =1  
 749      =1  /*=============================   ZW_UART0_rx_dma_eor_set =======================
 750      =1  **
 751      =1  **  Sets the End of Record (EoR) character. The EoR function makes it possible
 752      =1  **  to switch receive buffer when a certain character is recieved, .e.g Linefeed.
 753      =1  **  UART_RX_DMA_SWITCH_EOR must have been set in the ZW_UART0_rx_dma_init call
 754      =1  **  for the function to be enabled.
 755      =1  **
 756      =1  **  Parameters:
 757      =1  **
 758      =1  **   Side effects:
 759      =1  **--------------------------------------------------------------------------*/
 760      =1  void                    /*RET nothing */
 761      =1  ZW_UART0_rx_dma_eor_set(BYTE bChar);  /*IN EoR character */
 762      =1  
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 29  

 763      =1  /*=====================   ZW_UART0_rx_dma_byte_count_enable  =====================
 764      =1  **
 765      =1  **  Enables or disabled the function switch buffer when a certain byte count is
 766      =1  **  reached
 767      =1  **
 768      =1  **  Parameters: None
 769      =1  **
 770      =1  **   Side effects:
 771      =1  **--------------------------------------------------------------------------*/
 772      =1  void                    /*RET nothing */
 773      =1  ZW_UART0_rx_dma_byte_count_enable(BYTE bEnable); /* IN TRUE bute count switch is enabled */
 774      =1  
 775      =1  
 776      =1  
 777      =1  
 778      =1  
 779      =1  /*===============================   ZW_UART1_tx_dma_int_byte_count  ========================
 780      =1  **  Set interrupt tx byte count
 781      =1  **
 782      =1  **  Parameters
 783      =1  **
 784      =1  **   bByteCount: IN Interrupt is issued when this number of bytes has been DMA'ed to the UART
 785      =1  **                    Disabled when set to 0x00
 786      =1  **   Side effects:
 787      =1  **--------------------------------------------------------------------------*/
 788      =1  void                    /*RET Nothing */
 789      =1  ZW_UART1_tx_dma_int_byte_count( BYTE bByteCount);   /*IN Number of tx'ed bytes */
 790      =1  
 791      =1  /*===============================   ZW_UART1_tx_dma_inter_byte_delay  ========================
 792      =1  **  Set Tx inter byte delay
 793      =1  **  Parameters
 794      =1  **
 795      =1  **   bDelay:   IN Sets the inter byte delay 0x00 no delay (default after reset)
 796      =1  **                                          0x01  125ns delay
 797      =1  **                                          0x02  250ns delay
 798      =1  **                                                 :
 799      =1  **                                          0x0F 1875ns delay
 800      =1  **   Side effects:
 801      =1  **--------------------------------------------------------------------------*/
 802      =1  void                    /*RET Nothing */
 803      =1  ZW_UART1_tx_dma_inter_byte_delay( BYTE bDelay);   /*IN inter byte delay */
 804      =1  
 805      =1  /*===============================   ZW_UART1_tx_dma_data  ========================
 806      =1  **  Set buffer address and length and then start UART1 DMA
 807      =1  **  Parameters
 808      =1  **
 809      =1  **   pbAddress:  IN pointer to Tx buffer in lower 4kB XRAM
 810      =1  **   bBufferLen: IN length of Tx buffer in bytes
 811      =1  **
 812      =1  **   Side effects:
 813      =1  **       Discards any ongoing UART TX DMA process
 814      =1  **--------------------------------------------------------------------------*/
 815      =1  void                    /*RET Nothing */
 816      =1  ZW_UART1_tx_dma_data( XBYTE *pbAddress,    /*IN buffer base address */
 817      =1                        BYTE bBufferLen); /*IN buffer len */
 818      =1  
 819      =1  /*===============================   ZW_UART1_tx_dma_status  ========================
 820      =1  **  If the UART1 DMA process is ongoing this function Returns the status of this ongoing
 821      =1  **  process. Returns the status of the latest UART1 DMA process if the DMA has stopped.
 822      =1  **
 823      =1  **  Returned values:
 824      =1  **       UART_TX_DMA_STATUS_SLOW_XRAM: DMA can not keep up with configured inter byte
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 30  

 825      =1  **                                     process because of congestion in XRAM access
 826      =1  **       UART_TX_DMA_STATUS_RUNNING:   The DMA is transferring data to UART1
 827      =1  **
 828      =1  **  Parameters: None
 829      =1  **
 830      =1  **   Side effects:
 831      =1  **--------------------------------------------------------------------------*/
 832      =1  BYTE                    /*RET status */
 833      =1  ZW_UART1_tx_dma_status(void); /*IN Nothing */
 834      =1  
 835      =1  /*===============================   ZW_UART1_tx_dma_bytes_transferred  ========================
 836      =1  **  Returns the number of bytes that has been transferred to UART1 from XRAM for the ongoing DMA
 837      =1  **  process. If no transfer is ongoing the number of bytes that has been transferred to UART1
 838      =1  **  from XRAM from the latest process is returned.
 839      =1  **
 840      =1  **  Parameters: None
 841      =1  **
 842      =1  **   Side effects:
 843      =1  **--------------------------------------------------------------------------*/
 844      =1  BYTE                    /*RET bytes transferred */
 845      =1  ZW_UART1_tx_dma_bytes_transferred(void); /*IN Nothing */
 846      =1  
 847      =1  /*===============================   ZW_UART1_tx_dma_cancel  ========================
 848      =1  **  Cancels any ongoing DMA process and brings UART TX DMA to idle state
 849      =1  **
 850      =1  **  Parameters: None
 851      =1  **
 852      =1  **   Side effects:
 853      =1  **--------------------------------------------------------------------------*/
 854      =1  void                    /*RET nothing */
 855      =1  ZW_UART1_tx_dma_cancel(void); /*IN Nothing */
 856      =1  
 857      =1  /*===============================   ZW_UART1_rx_dma_init  ===============================
 858      =1  **  Initialize the buffers and setup for the UART1 Rx DMA
 859      =1  **
 860      =1  **  Parameters
 861      =1  **     pbAddress:  IN pointer to the base address of the two Rx buffers
 862      =1  **     bBufLength: IN length of UART1 RX Buffer - must be greater than 0
 863      =1  **     bBitMap:    IN bit mask contains the setting of the Rx DMA
 864      =1  **                      UART_RX_DMA_LOD_INT_EN    Enable Loss Of Data interrupt
 865      =1  **                      UART_RX_DMA_SWITCH_COUNT  Switch buffer when byte count is reached
 866      =1  **                      UART_RX_DMA_SWITCH_FULL   Switch buffer when buffer full
 867      =1  **
 868      =1  **    Side effects:
 869      =1  **       Discards any ongoing UART RX DMA process
 870      =1  **       Clears status information
 871      =1  **-------------------------------------------------------------------------------------*/
 872      =1  void                    /*RET Nothing */
 873      =1  ZW_UART1_rx_dma_init( XBYTE *pbAddress, /*IN pointer to base address of RX buffers */
 874      =1                        BYTE bBufLength, /* IN buffer byte length */
 875      =1                        BYTE bBitMap); /*IN the rx dmaBuf's threshold value of the almost full flag*/
 876      =1  
 877      =1  /*===============================   ZW_UART1_rx_dma_int_byte_count  ===============================
 878      =1  **  Set interrupt rx byte count. A value of 0x00 means disabled
 879      =1  **
 880      =1  **   bByteCount: IN Interrupt is issued when this number of bytes has been DMA'ed from the UART
 881      =1  **                  Disabled when set to 0x00
 882      =1  **    Side effects:
 883      =1  **-------------------------------------------------------------------------------------*/
 884      =1  void                    /*RET Nothing */
 885      =1  ZW_UART1_rx_dma_int_byte_count(BYTE bByteCount); /*IN */
 886      =1  
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 31  

 887      =1  /*===============================   ZW_UART1_rx_dma_status  ========================
 888      =1  **  If the UART1 RX DMA process is ongoing this function returns the status of this ongoing
 889      =1  **  process. Returns the status of the latest UART1 RX DMA process if the DMA has stopped.
 890      =1  **
 891      =1  **  Returned values:
 892      =1  **       UART_RX_DMA_STATUS_EOR:     The DMA switched RX buffer because it has
 893      =1  **                                   recieved an End of Record char
 894      =1  **       UART_RX_DMA_STATUS_LOD:     DMA can not keep up with the speed of the incomming data
 895      =1  **       UART_RX_DMA_STATUS_CURBUF1: Set when the UART1 RX DMA currently is transferring data
 896      =1  **                                   from buffer 1. When cleared the UART1 RX DMA currently is
 897      =1  **                                   transferring data from buffer 0
 898      =1  **       UART_RX_DMA_STATUS_BUFFULL: Set when a buffer has been filled to the limit
 899      =1  **       UART_RX_DMA_STATUS_RUNNING: The DMA is enabled
 900      =1  **
 901      =1  **  Parameters: None
 902      =1  **
 903      =1  **   Side effects:
 904      =1  **--------------------------------------------------------------------------*/
 905      =1  BYTE                    /*RET status */
 906      =1  ZW_UART1_rx_dma_status(void); /*IN Nothing */
 907      =1  
 908      =1  /*===============================   ZW_UART1_rx_dma_bytes_transferred  ========================
 909      =1  **  Returns the number of bytes that has been transferred to UART1 to XRAM for the ongoing DMA
 910      =1  **  process.
 911      =1  **
 912      =1  **  Parameters: None
 913      =1  **
 914      =1  **   Side effects:
 915      =1  **--------------------------------------------------------------------------*/
 916      =1  BYTE                    /*RET bytes transferred */
 917      =1  ZW_UART1_rx_dma_bytes_transferred(void); /*IN Nothing */
 918      =1  
 919      =1  /*===============================   ZW_UART1_rx_dma_cancel  ========================
 920      =1  **  Cancels any ongoing DMA process and brings UART RX DMA to idle state
 921      =1  **
 922      =1  **  Parameters: None
 923      =1  **
 924      =1  **   Side effects:
 925      =1  **--------------------------------------------------------------------------*/
 926      =1  void                    /*RET nothing */
 927      =1  ZW_UART1_rx_dma_cancel(void); /*IN Nothing */
 928      =1  
 929      =1  
 930      =1  /*=============================   ZW_UART1_rx_dma_eor_set =======================
 931      =1  **
 932      =1  **  Sets the End of Record (EoR) character. The EoR function makes it possible
 933      =1  **  to switch receive buffer when a certain character is recieved, .e.g Linefeed.
 934      =1  **  UART_RX_DMA_SWITCH_EOR must have been set in the ZW_UART1_rx_dma_init call
 935      =1  **  for the function to be enabled.
 936      =1  **
 937      =1  **  Parameters:
 938      =1  **
 939      =1  **   Side effects:
 940      =1  **--------------------------------------------------------------------------*/
 941      =1  void                    /*RET nothing */
 942      =1  ZW_UART1_rx_dma_eor_set(BYTE bChar);  /*IN EoR character */
 943      =1  
 944      =1  /*=====================   ZW_UART1_rx_dma_byte_count_enable  =====================
 945      =1  **
 946      =1  **  Enables or disabled the function switch buffer when a certain byte count is
 947      =1  **  reached
 948      =1  **
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 32  

 949      =1  **  Parameters: None
 950      =1  **
 951      =1  **   Side effects:
 952      =1  **--------------------------------------------------------------------------*/
 953      =1  void                    /*RET nothing */
 954      =1  ZW_UART1_rx_dma_byte_count_enable(BYTE bEnable); /* IN TRUE bute count switch is enabled */
 955      =1  
 956      =1  
 957      =1  #endif /* _ZW_UART_API_H_ */
  31          #include <misc.h>
   1      =1  /**
   2      =1   * @file
   3      =1   * Miscellaneous stuff.
   4      =1   * @copyright Copyright (c) 2001-2017, Sigma Designs Inc., All Rights Reserved
   5      =1   */
   6      =1  
   7      =1  #ifndef _MISC_H_
   8      =1  #define _MISC_H_
   9      =1  
  10      =1  /****************************************************************************/
  11      =1  /*                              INCLUDE FILES                               */
  12      =1  /****************************************************************************/
  13      =1  #include <ZW_typedefs.h>
   1      =2  /*******************************  ZW_typedefs.h  *******************************
   2      =2   *           #######
   3      =2   *           ##  ##
   4      =2   *           #  ##    ####   #####    #####  ##  ##   #####
   5      =2   *             ##    ##  ##  ##  ##  ##      ##  ##  ##
   6      =2   *            ##  #  ######  ##  ##   ####   ##  ##   ####
   7      =2   *           ##  ##  ##      ##  ##      ##   #####      ##
   8      =2   *          #######   ####   ##  ##  #####       ##  #####
   9      =2   *                                           #####
  10      =2   *          Products that speak Z-Wave work together better
  11      =2   *
  12      =2   *              Copyright (c) 2008
  13      =2   *              Zensys A/S
  14      =2   *              Denmark
  15      =2   *
  16      =2   *              All Rights Reserved
  17      =2   *
  18      =2   *    This source file is subject to the terms and conditions of the
  19      =2   *    Zensys Software License Agreement which restricts the manner
  20      =2   *    in which it may be used.
  21      =2   *
  22      =2   *---------------------------------------------------------------------------
  23      =2   *
  24      =2   * Description: Module description
  25      =2   *
  26      =2   * Author:   Ivar Jeppesen
  27      =2   *
  28      =2   * Last Changed By:  $Author: efh $
  29      =2   * Revision:         $Revision: 29359 $
  30      =2   * Last Changed:     $Date: 2014-07-11 11:13:33 +0200 (fr, 11 jul 2014) $
  31      =2   *
  32      =2   ****************************************************************************/
  33      =2  #ifndef _ZW_TYPEDEFS_H_
  14      =1  //#include <ZW_classcmd.h>
  15      =1  #include <ZW_transport_api.h>
   1      =2  /****************************************************************************
   2      =2   *
   3      =2   * Copyright (c) 2001-2013
   4      =2   * Sigma Designs, Inc.
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 33  

   5      =2   * All Rights Reserved
   6      =2   *
   7      =2   *---------------------------------------------------------------------------
   8      =2   *
   9      =2   * Description: Z-Wave Transport Application layer interface
  10      =2   *
  11      =2   * Author:   Ivar Jeppesen
  12      =2   *
  13      =2   * Last Changed By:  $Author: jsi $
  14      =2   * Revision:         $Revision: 31344 $
  15      =2   * Last Changed:     $Date: 2015-04-17 13:53:23 +0200 (fr, 17 apr 2015) $
  16      =2   *
  17      =2   ****************************************************************************/
  18      =2  /**
  19      =2   * \file ZW_transport_api.h
  20      =2   * \brief Z-Wave Transport Application layer interface.
  21      =2   *
  22      =2   * The Z Wave transport layer controls transfer of data between Z Wave nodes
  23      =2   * including retransmission, frame check and acknowledgement. The Z Wave
  24      =2   * transport interface includes functions for transfer of data to other Z Wave
  25      =2   * nodes. Application data received from other nodes is handed over to the
  26      =2   * application via the \ref ApplicationCommandHandler function. The ZW_MAX_NODES
  27      =2   * define defines the maximum of nodes possible in a Z Wave network.
  28      =2   */
  29      =2  #ifndef _ZW_TRANSPORT_API_H_
  30      =2  #define _ZW_TRANSPORT_API_H_
  31      =2  #include <ZW_security_api.h>
   1      =3  /***************************************************************************
   2      =3  *
   3      =3  * Copyright (c) 2013
   4      =3  * Sigma Designs, Inc.
   5      =3  * All Rights Reserved
   6      =3  *
   7      =3  *---------------------------------------------------------------------------
   8      =3  *
   9      =3  * Description: Some nice descriptive description.
  10      =3  *
  11      =3  * Author:   Jakob Buron
  12      =3  *
  13      =3  * Last Changed By:  $Author: jdo $
  14      =3  * Revision:         $Revision: 1.38 $
  15      =3  * Last Changed:     $Date: 2005/07/27 15:12:54 $
  16      =3  *
  17      =3  ****************************************************************************/
  18      =3  #ifndef ZW_SECURITY_API_H_
  19      =3  #define ZW_SECURITY_API_H_
  20      =3  
  21      =3  /****************************************************************************/
  22      =3  /*                              INCLUDE FILES                               */
  23      =3  /****************************************************************************/
  24      =3  #include <ZW_typedefs.h>
   1      =4  /*******************************  ZW_typedefs.h  *******************************
   2      =4   *           #######
   3      =4   *           ##  ##
   4      =4   *           #  ##    ####   #####    #####  ##  ##   #####
   5      =4   *             ##    ##  ##  ##  ##  ##      ##  ##  ##
   6      =4   *            ##  #  ######  ##  ##   ####   ##  ##   ####
   7      =4   *           ##  ##  ##      ##  ##      ##   #####      ##
   8      =4   *          #######   ####   ##  ##  #####       ##  #####
   9      =4   *                                           #####
  10      =4   *          Products that speak Z-Wave work together better
  11      =4   *
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 34  

  12      =4   *              Copyright (c) 2008
  13      =4   *              Zensys A/S
  14      =4   *              Denmark
  15      =4   *
  16      =4   *              All Rights Reserved
  17      =4   *
  18      =4   *    This source file is subject to the terms and conditions of the
  19      =4   *    Zensys Software License Agreement which restricts the manner
  20      =4   *    in which it may be used.
  21      =4   *
  22      =4   *---------------------------------------------------------------------------
  23      =4   *
  24      =4   * Description: Module description
  25      =4   *
  26      =4   * Author:   Ivar Jeppesen
  27      =4   *
  28      =4   * Last Changed By:  $Author: efh $
  29      =4   * Revision:         $Revision: 29359 $
  30      =4   * Last Changed:     $Date: 2014-07-11 11:13:33 +0200 (fr, 11 jul 2014) $
  31      =4   *
  32      =4   ****************************************************************************/
  33      =4  #ifndef _ZW_TYPEDEFS_H_
  25      =3  
  26      =3  /****************************************************************************/
  27      =3  /*                     EXPORTED TYPES and DEFINITIONS                       */
  28      =3  /****************************************************************************/
  29      =3  /* The security key a frame was received with or should be sent with.
  30      =3   *
  31      =3   * Special values:
  32      =3  */
  33      =3  typedef enum SECURITY_KEY
  34      =3  {
  35      =3    SECURITY_KEY_NONE = 0x00,
  36      =3    SECURITY_KEY_S2_UNAUTHENTICATED = 0x01,
  37      =3    SECURITY_KEY_S2_AUTHENTICATED = 0x02,
  38      =3    SECURITY_KEY_S2_ACCESS = 0x03,
  39      =3    SECURITY_KEY_S0 = 0x04,
  40      =3  } security_key_t;
  41      =3  
  42      =3  
  43      =3  /**
  44      =3   * Bitmask for security keys. Used by \ref ZW_GetSecurityKeys.
  45      =3   */
  46      =3  #define SECURITY_KEY_S2_UNAUTHENTICATED_BIT 0x01
  47      =3  #define SECURITY_KEY_S2_AUTHENTICATED_BIT 0x02
  48      =3  #define SECURITY_KEY_S2_ACCESS_BIT 0x04
  49      =3  #define SECURITY_KEY_S0_BIT 0x80
  50      =3  
  51      =3  #define SECURITY_KEY_S2_MASK (SECURITY_KEY_S2_UNAUTHENTICATED_BIT \
  52      =3                                | SECURITY_KEY_S2_AUTHENTICATED_BIT \
  53      =3                                | SECURITY_KEY_S2_ACCESS_BIT)
  54      =3  #define SECURITY_KEY_NONE_MASK 0x00
  55      =3  
  56      =3  
  57      =3  /**
  58      =3   * Security S2 Public DSK Key length
  59      =3   */
  60      =3  #define SECURITY_KEY_S2_PUBLIC_DSK_LENGTH     16
  61      =3  
  62      =3  
  63      =3  /**
  64      =3   * Security S2 Public CSA DSK Key length
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 35  

  65      =3   */
  66      =3  #define SECURITY_KEY_S2_PUBLIC_CSA_DSK_LENGTH 4
  67      =3  
  68      =3  
  69      =3  /**
  70      =3   *  definitions for Security S2 inclusion Authentication
  71      =3   */
  72      =3  typedef enum _E_SECURTIY_S2_AUTHENTICATION_
  73      =3  {
  74      =3    SECURITY_AUTHENTICATION_SSA = 0x00,
  75      =3    SECURITY_AUTHENTICATION_CSA = 0x01
  76      =3  } e_security_s2_authentication_t;
  77      =3  
  78      =3  
  79      =3  typedef struct _S_SECURITY_S2_INCLUSION_CSA_PUBLIC_DSK_
  80      =3  {
  81      =3    BYTE aCSA_DSK[SECURITY_KEY_S2_PUBLIC_CSA_DSK_LENGTH];
  82      =3  } s_SecurityS2InclusionCSAPublicDSK_t;
  83      =3  
  84      =3  
  85      =3  /**
  86      =3   * Definitions for Application bound Security events
  87      =3   * Delivered from protocol to Application through the Application implmemented
  88      =3   * ApplicationSecurityEvent(s_application_security_event_data_t)
  89      =3   */
  90      =3  typedef enum _E_APPLICATION_SECURITY_EVENT_
  91      =3  {
  92      =3    E_APPLICATION_SECURITY_EVENT_S2_INCLUSION_REQUEST_DSK_CSA
  93      =3  } e_application_security_event_t;
  94      =3  
  95      =3  
  96      =3  /**
  97      =3   *
  98      =3   *
  99      =3   */
 100      =3  typedef struct _S_APPLICATION_SECURITY_EVENT_DATA_
 101      =3  {
 102      =3    e_application_security_event_t event;
 103      =3    BYTE eventDataLength;
 104      =3    BYTE *eventData;
 105      =3  } s_application_security_event_data_t;
 106      =3  
 107      =3  
 108      =3  /**
 109      =3  * Application must implement this. Used by protocol to request/inform Application
 110      =3  * of Security based Events. Currently only an event for Client Side Authentication (CSA)
 111      =3  * has been defined - E_APPLICATION_SECURITY_EVENT_S2_INCLUSION_REQUEST_DSK_CSA.
 112      =3  *
 113      =3  * \ref E_APPLICATION_SECURITY_EVENT_S2_INCLUSION_REQUEST_DSK_CSA Security Event
 114      =3  *   Is posted by protocol when in S2 inclusion with CSA enabled and the
 115      =3  *   Server side DSK is needed.
 116      =3  *   Application must call ZW_SetSecurityS2InclusionCSA_DSK(s_SecurityS2InclusionCSAPublicDSK_t *)
 117      =3  *   with the retrieved Server/Controller side DSK.
 118      =3  *
 119      =3  *   @param[in] securityEvent  Pointer to structure containing the security event
 120      =3  *                             and any possible data connected to the event.
 121      =3  */
 122      =3  void ApplicationSecurityEvent(s_application_security_event_data_t *securiyEvent);
 123      =3  
 124      =3  
 125      =3  /**
 126      =3  * Application must implement this function
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 36  

 127      =3  * NOTE: If Z-Wave framework are used then ApplicationSecureCommandsSupported
 128      =3  *       are allready implemented in \ref ZW_TransportSecProtocol.c.
 129      =3  */
 130      =3  void
 131      =3  ApplicationSecureCommandsSupported(
 132      =3      enum SECURITY_KEY eKey, /* IN Security Key to report on */
 133      =3      BYTE **pCmdClasses,           /* OUT Cmd classes supported by endpoint */
 134      =3      BYTE *pLength);               /* OUT Length of pCmdClasses, 0 if endpoint does not exist */
 135      =3  
 136      =3  
 137      =3  /**
 138      =3  * Application must implement this function to return a bitmask of the
 139      =3  * security keys requested by the node when joining a network.
 140      =3  * The including controller may grant all or a subset of the requested
 141      =3  * keys.
 142      =3  * Supported keys:
 143      =3  * \ref SECURITY_KEY_S0_BIT;
 144      =3  * \ref SECURITY_KEY_S2_ACCESS_BIT;
 145      =3  * \ref SECURITY_KEY_S2_AUTHENTICATED_BIT;
 146      =3  * \ref SECURITY_KEY_S2_UNAUTHENTICATED_BIT;
 147      =3  * \return A bitmask of supported security keys.
 148      =3  *
 149      =3  */
 150      =3  BYTE ApplicationSecureKeysRequested(void);
 151      =3  
 152      =3  
 153      =3  /**
 154      =3  * Application must implement this function to return a value of the
 155      =3  * security authentication requested by the node when joining a network.
 156      =3  * Supported methods:
 157      =3  * \ref SECURITY_AUTHENTICATION_SSA;
 158      =3  * \ref SECURITY_AUTHENTICATION_CSA;
 159      =3  *
 160      =3  */
 161      =3  BYTE ApplicationSecureAuthenticationRequested(void);
 162      =3  
 163      =3  
 164      =3  /**
 165      =3   *    @brief
 166      =3   *    Set the Controller DSK requested by protocol for CSA inclusion through
 167      =3   *    calling ApplicationSecurityS2InclusionRequestDSK_CSA
 168      =3   *
 169      =3   *    @param[in] response retrieved CSA DSK
 170      =3   *
 171      =3   */
 172      =3  void ZW_SetSecurityS2InclusionPublicDSK_CSA(s_SecurityS2InclusionCSAPublicDSK_t *response);
 173      =3  
 174      =3  
 175      =3  /*===========================   ZW_GetSecurityKeys   =========================
 176      =3  **
 177      =3  **    Returns a bitmask of security keys the application can request
 178      =3  **    ZW_SendDataEX() to use. When the node is excluded, no security keys
 179      =3  **    will be reported.
 180      =3  **
 181      =3  **    Side effects:
 182      =3  **
 183      =3  **--------------------------------------------------------------------------*/
 184      =3  BYTE ZW_GetSecurityKeys(void);
 185      =3  
 186      =3  
 187      =3  /*======================   ZW_SetSecurityS0NetworkKey   ======================
 188      =3  **    @brief
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 37  

 189      =3  **    Set the network key S0 in the protocol.
 190      =3  **    This function is only to be called after a firmware update from an
 191      =3  **    application based upon an SDK prior to 6.70, as example 6.51, 6.60, or
 192      =3  **    6.61 to an application based upon SDK 6.70 or later.
 193      =3  **
 194      =3  **    Note: This is only relevant for a node that was securely included in an
 195      =3  **          S0 based network.
 196      =3  **
 197      =3  **    @param[in] network_key  Pointer to the S0 network key for the home
 198      =3  **                            network. 16 bytes long.
 199      =3  **
 200      =3  **    Side effects:
 201      =3  **
 202      =3  **--------------------------------------------------------------------------*/
 203      =3  void ZW_SetSecurityS0NetworkKey(BYTE * network_key);
 204      =3  
 205      =3  
 206      =3  /**
 207      =3   *
 208      =3   *
 209      =3   */
 210      =3  void ZW_GetSecurityS2PublicDSK(BYTE *buf);
 211      =3  
 212      =3  
 213      =3  #ifdef ZW_SECURITY_PROTOCOL_SINGLE_NETWORK_KEY
 220      =3  
 221      =3  
 222      =3  /*
 223      =3   *
 224      =3   *
 225      =3   */
 226      =3  void ZW_s2_inclusion_init(void);
 227      =3  
 228      =3  
 229      =3  #endif /* ZW_SECURITY_API_H_ */
  32      =2  #include <ZW_nodemask_api.h>
   1      =3  /*******************************  ZW_NODEMASK_API.H  *******************************
   2      =3   *           #######
   3      =3   *           ##  ##
   4      =3   *           #  ##    ####   #####    #####  ##  ##   #####
   5      =3   *             ##    ##  ##  ##  ##  ##      ##  ##  ##
   6      =3   *            ##  #  ######  ##  ##   ####   ##  ##   ####
   7      =3   *           ##  ##  ##      ##  ##      ##   #####      ##
   8      =3   *          #######   ####   ##  ##  #####       ##  #####
   9      =3   *                                           #####
  10      =3   *          Z-Wave, the wireless language.
  11      =3   *
  12      =3   *              Copyright (c) 2001
  13      =3   *              Zensys A/S
  14      =3   *              Denmark
  15      =3   *
  16      =3   *              All Rights Reserved
  17      =3   *
  18      =3   *    This source file is subject to the terms and conditions of the
  19      =3   *    Zensys Software License Agreement which restricts the manner
  20      =3   *    in which it may be used.
  21      =3   *
  22      =3   *---------------------------------------------------------------------------
  23      =3   *
  24      =3   * Description: Functions used to manipulate bits (Node ID) in a NodeMask array.
  25      =3   *
  26      =3   * Author:   Ivar Jeppesen
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 38  

  27      =3   *
  28      =3   * Last Changed By:  $Author: jbu $
  29      =3   * Revision:         $Revision: 26038 $
  30      =3   * Last Changed:     $Date: 2013-06-10 09:08:11 +0200 (ma, 10 jun 2013) $
  31      =3   *
  32      =3   ****************************************************************************/
  33      =3  #ifndef _ZW_NODEMASK_API_H_
  34      =3  #define _ZW_NODEMASK_API_H_
  35      =3  
  36      =3  /****************************************************************************/
  37      =3  /*                              INCLUDE FILES                               */
  38      =3  /****************************************************************************/
  39      =3  
  40      =3  
  41      =3  /****************************************************************************/
  42      =3  /*                     EXPORTED TYPES and DEFINITIONS                       */
  43      =3  /****************************************************************************/
  44      =3  
  45      =3  /*The max length of a node mask*/
  46      =3  #define MAX_NODEMASK_LENGTH   (ZW_MAX_NODES/8)
  47      =3  
  48      =3  /****************************  NodeMask  ************************************
  49      =3  ** Functions used to manipulate bits (Node ID) in a byte array (NodeMask array)
  50      =3  **
  51      =3  *****************************************************************************/
  52      =3  
  53      =3  /*===========================   ZW_NodeMaskSetBit   =========================
  54      =3  **    Set the node bit in a node bitmask
  55      =3  **
  56      =3  ** void           RET   Nothing
  57      =3  ** ZW_NodeMaskSetBit(
  58      =3  ** BYTE_P pMask,         IN   pointer nodemask
  59      =3  ** BYTE bNodeID);        IN   node to set in nodemask
  60      =3  **--------------------------------------------------------------------------*/
  61      =3  #define ZW_NODE_MASK_SET_BIT(pMask, bNodeID) ZW_NodeMaskSetBit(pMask, bNodeID)
  62      =3  
  63      =3  /*========================   NodeMaskClearBit   =============================
  64      =3  **    Set the node bit in a node bitmask
  65      =3  **
  66      =3  ** void       RET   Nothing
  67      =3  ** ZW_NodeMaskClearBit(
  68      =3  ** BYTE_P pMask,     IN   nodemask
  69      =3  ** BYTE bNodeID);    IN   node to clear in nodemask
  70      =3  **--------------------------------------------------------------------------*/
  71      =3  #define ZW_NODE_MASK_CLEAR_BIT(pMask, bNodeID) ZW_NodeMaskClearBit(pMask, bNodeID)
  72      =3  
  73      =3  /*===========================   ZW_NodeMaskClear   ==========================
  74      =3  **    Clear all bits in a nodemask
  75      =3  **
  76      =3  ** void       RET   Nothing
  77      =3  ** ZW_NodeMaskClear(
  78      =3  ** BYTE_P pMask,     IN   nodemask
  79      =3  ** BYTE bLength);    IN   length of nodemask
  80      =3  **--------------------------------------------------------------------------*/
  81      =3  #define ZW_NODE_MASK_CLEAR(pMask, bLength) ZW_NodeMaskClear(pMask, bLength)
  82      =3  
  83      =3  /*==========================   ZW_NodeMaskBitsIn   ==========================
  84      =3  **    Check is any bit is set in a nodemask
  85      =3  **
  86      =3  ** BYTE       RET   Number of bits set in nodemask
  87      =3  ** ZW_NodeMaskBitsIn(
  88      =3  ** BYTE_P pMask,     IN   pointer to nodemask
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 39  

  89      =3  ** BYTE bLength);    IN   length of nodemask
  90      =3  **--------------------------------------------------------------------------*/
  91      =3  #define ZW_NODE_MASK_BITS_IN(pMask, bLength) ZW_NodeMaskBitsIn(pMask, bLength)
  92      =3  
  93      =3  /*==========================   ZW_NodeMaskNodeIn   ==========================
  94      =3  **    Check if a node is in a nodemask
  95      =3  **
  96      =3  ** BYTE       RET   ZERO if not in nodemask, NONEZERO if in nodemask
  97      =3  ** ZW_NodeMaskNodeIn(
  98      =3  ** BYTE_P pMask,     IN   pointer to nodemask to check for bNode
  99      =3  ** BYTE bNode);      IN   bit number that should be checked
 100      =3  **--------------------------------------------------------------------------*/
 101      =3  #define ZW_NODE_MASK_NODE_IN(pMask, bNode) ZW_NodeMaskNodeIn(pMask, bNode)
 102      =3  
 103      =3  
 104      =3  
 105      =3  /****************************************************************************/
 106      =3  /*                              EXPORTED DATA                               */
 107      =3  /****************************************************************************/
 108      =3  
 109      =3  /****************************************************************************/
 110      =3  /*                           EXPORTED FUNCTIONS                             */
 111      =3  /****************************************************************************/
 112      =3  
 113      =3  /*===========================   ZW_NodeMaskSetBit   =========================
 114      =3  **    Set the node bit in a node bitmask
 115      =3  **
 116      =3  **    Side effects
 117      =3  **
 118      =3  **--------------------------------------------------------------------------*/
 119      =3  extern void           /*RET   Nothing                 */
 120      =3  ZW_NodeMaskSetBit(
 121      =3  BYTE_P pMask,         /* IN   pointer nodemask        */
 122      =3  BYTE bNodeID);         /* IN   node to set in nodemask */
 123      =3  
 124      =3  /*========================   NodeMaskClearBit   =============================
 125      =3  **    Set the node bit in a node bitmask
 126      =3  **
 127      =3  **    Side effects
 128      =3  **
 129      =3  **--------------------------------------------------------------------------*/
 130      =3  extern void       /*RET   Nothing                   */
 131      =3  ZW_NodeMaskClearBit(
 132      =3  BYTE_P pMask,     /* IN   nodemask                  */
 133      =3  BYTE bNodeID);     /* IN   node to clear in nodemask */
 134      =3  
 135      =3  /*===========================   ZW_NodeMaskClear   ==========================
 136      =3  **    Clear all bits in a nodemask
 137      =3  **
 138      =3  **    Side effects
 139      =3  **
 140      =3  **--------------------------------------------------------------------------*/
 141      =3  extern void       /*RET   Nothing             */
 142      =3  ZW_NodeMaskClear(
 143      =3  BYTE_P pMask,     /* IN   nodemask            */
 144      =3  BYTE bLength);     /* IN   length of nodemask  */
 145      =3  
 146      =3  /*==========================   ZW_NodeMaskBitsIn   ==========================
 147      =3  **    Check is any bit is set in a nodemask
 148      =3  **
 149      =3  **--------------------------------------------------------------------------*/
 150      =3  extern BYTE       /*RET   Number of bits set in nodemask  */
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 40  

 151      =3  ZW_NodeMaskBitsIn(
 152      =3  BYTE_P pMask,     /* IN   pointer to nodemask             */
 153      =3  BYTE bLength);     /* IN   length of nodemask              */
 154      =3  
 155      =3  /*==========================   ZW_NodeMaskNodeIn   ==========================
 156      =3  **    Check if a node is in a nodemask
 157      =3  **
 158      =3  **--------------------------------------------------------------------------*/
 159      =3  extern BYTE       /*RET   ZERO if not in nodemask, NONEZERO if in nodemask  */
 160      =3  ZW_NodeMaskNodeIn(
 161      =3  BYTE_P pMask,     /* IN   pointer to nodemask to check for bNode            */
 162      =3  BYTE bNode);      /* IN   bit number that should be checked                 */
 163      =3  
 164      =3  /*==========================   ZW_NodeMaskGetNextNode   =====================
 165      =3  ** Function:    Find the next NodeId that is set in a nodemask
 166      =3  **
 167      =3  ** Parameters:
 168      =3  **   currentNodeId                  =  last NodeId found (0 for first call)
 169      =3  **   pMask                          -> Nodemask that should be searched
 170      =3  **
 171      =3  ** Return:
 172      =3  **   If found                       = Next NodeId from the nodemask.
 173      =3  **   If not found                   = 0
 174      =3  **
 175      =3  **--------------------------------------------------------------------------*/
 176      =3  extern BYTE
 177      =3  ZW_NodeMaskGetNextNode(
 178      =3    BYTE currentNodeId,
 179      =3    BYTE_P pMask);
 180      =3  
 181      =3  #endif /* _ZW_NODEMASK_API_H_ */
  33      =2  
  34      =2  /****************************************************************************/
  35      =2  /*                              INCLUDE FILES                               */
  36      =2  /****************************************************************************/
  37      =2  
  38      =2  /****************************************************************************/
  39      =2  /*                     EXPORTED TYPES and DEFINITIONS                       */
  40      =2  /****************************************************************************/
  41      =2  
  42      =2  /* Max number of nodes in a Z-wave system */
  43      =2  #define ZW_MAX_NODES        232
  44      =2  
  45      =2  /************************************************************/
  46      =2  /* Node Information frame*/
  47      =2  /************************************************************/
  48      =2  #define NODEPARM_MAX  35   /* max. number of parameters */
  49      =2  
  50      =2  
  51      =2  /* Transmit frame option flags */
  52      =2  #define TRANSMIT_OPTION_ACK                     0x01    /* request acknowledge from destination node */
  53      =2  #define TRANSMIT_OPTION_LOW_POWER               0x02    /* transmit at low output power level (1/3 of norm
             -al RF range) */
  54      =2  #define TRANSMIT_OPTION_MULTICAST_AS_BROADCAST  0x02    /* The multicast frame should be send as a broadca
             -st */
  55      =2  #ifdef ZW_SLAVE
  56      =2  #define TRANSMIT_OPTION_RETURN_ROUTE            0x04    /* request transmission via return route */
  57      =2  #endif
  58      =2  #define TRANSMIT_OPTION_AUTO_ROUTE              0x04    /* request retransmission via repeater nodes */
  59      =2  /* do not use response route - Even if available */
  60      =2  #define TRANSMIT_OPTION_NO_ROUTE                0x10
  61      =2  /* Use explore frame if needed */
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 41  

  62      =2  #define TRANSMIT_OPTION_EXPLORE                 0x20
  63      =2  
  64      =2  /* Transmit frame option flag which are valid when sending explore frames  */
  65      =2  #define TRANSMIT_EXPLORE_OPTION_ACK         TRANSMIT_OPTION_ACK
  66      =2  #define TRANSMIT_EXPLORE_OPTION_LOW_POWER   TRANSMIT_OPTION_LOW_POWER
  67      =2  
  68      =2  /* Allow Transport Service segmentation of long messages */
  69      =2  #define TRANSMIT_OPTION_2_TRANSPORT_SERVICE 0x01
  70      =2  #define TRANSMIT_OPTION_2_FOLLOWUP          0x08
  71      =2  
  72      =2  /* Received frame status flags */
  73      =2  /**
  74      =2   *  \defgroup RECEIVE_STATUS Status codes for receiving frames.
  75      =2   * \addtogroup RECEIVE_STATUS
  76      =2   * @{
  77      =2   */
  78      =2  
  79      =2  /**
  80      =2   * A response route is locked by the application
  81      =2   */
  82      =2  #define RECEIVE_STATUS_ROUTED_BUSY    0x01
  83      =2  /**
  84      =2   * Received at low output power level, this must
  85      =2   * have the same value as TRANSMIT_OPTION_LOW_POWER
  86      =2   */
  87      =2  #define RECEIVE_STATUS_LOW_POWER      0x02
  88      =2  /**
  89      =2   * Mask for masking out the received frametype bits
  90      =2   */
  91      =2  #define RECEIVE_STATUS_TYPE_MASK      0x0C
  92      =2  /**
  93      =2   * Received frame is singlecast frame (rxOptions == xxxx00xx)
  94      =2   */
  95      =2  #define RECEIVE_STATUS_TYPE_SINGLE    0x00
  96      =2  /**
  97      =2   * Received frame is broadcast frame  (rxOptions == xxxx01xx)
  98      =2   */
  99      =2  #define RECEIVE_STATUS_TYPE_BROAD     0x04
 100      =2  /**
 101      =2   * Received frame is multicast frame (rxOptions == xxxx10xx)
 102      =2   */
 103      =2  #define RECEIVE_STATUS_TYPE_MULTI     0x08
 104      =2  /**
 105      =2   * Received frame is an explore frame (rxOptions == xxx1xxxx)
 106      =2   * Only TYPE_BROAD can be active at the same time as TYPE_EXPLORE
 107      =2   */
 108      =2  #define RECEIVE_STATUS_TYPE_EXPLORE   0x10
 109      =2  /**
 110      =2   * Received frame is not send to me (rxOptions == x1xxxxxx)
 111      =2   * - useful only in promiscuous mode
 112      =2   */
 113      =2  #define RECEIVE_STATUS_FOREIGN_FRAME  0x40
 114      =2  /**
 115      =2   * Received frame is send on another network (rxOptions == 1xxxxxxx)
 116      =2   * - useful only in Smart Start - used when receiving INIF from another network
 117      =2   */
 118      =2  #define RECEIVE_STATUS_FOREIGN_HOMEID 0x80
 119      =2  
 120      =2  /**
 121      =2   * @}
 122      =2   */
 123      =2  
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 42  

 124      =2  /* Predefined Node ID's */
 125      =2  #define NODE_BROADCAST              0xFF    /* broadcast */
 126      =2  #define ZW_TEST_NOT_A_NODEID        0x00    /* */
 127      =2  
 128      =2  /* Transmit complete codes */
 129      =2  #define TRANSMIT_COMPLETE_OK      0x00
 130      =2  #define TRANSMIT_COMPLETE_NO_ACK  0x01  /* retransmission error */
 131      =2  #define TRANSMIT_COMPLETE_FAIL    0x02  /* transmit error */
 132      =2  #define TRANSMIT_ROUTING_NOT_IDLE 0x03  /* transmit error */
 133      =2  #ifdef ZW_CONTROLLER
 138      =2  #define TRANSMIT_COMPLETE_VERIFIED 0x05 /* Verified delivery */
 139      =2  
 140      =2  /* ZW_REDISCOVERY_NEEDED callback values. */
 141      =2  /* Note that they are different from ZW_REQUEST_NETWORK_UPDATE callbacks */
 142      =2  #define ZW_ROUTE_LOST_FAILED      0x04  /*Node Asked wont help us*/
 143      =2  #define ZW_ROUTE_LOST_ACCEPT      0x05  /*Accepted to help*/
 144      =2  
 145      =2  
 146      =2  #ifdef ZW_ROUTING_DEMO
 150      =2  
 151      =2  #define ZW_MAX_CACHED_RETURN_ROUTE_DESTINATIONS  5
 152      =2  
 153      =2  #define ZW_RF_TEST_SIGNAL_CARRIER              0x00
 154      =2  #define ZW_RF_TEST_SIGNAL_CARRIER_MODULATED    0x01
 155      =2  
 156      =2  /* Max hops in route */
 157      =2  #define MAX_REPEATERS      4
 158      =2  
 159      =2  
 160      =2  /* TX_STATUS_TYPE Last Used Route array size definitions */
 161      =2  #define LAST_USED_ROUTE_CONF_SIZE               1
 162      =2  #define LAST_USED_ROUTE_SIZE                    (MAX_REPEATERS + LAST_USED_ROUTE_CONF_SIZE)
 163      =2  
 164      =2  /* TX_STATUS_TYPE Last Used Route array index definitions */
 165      =2  #define LAST_USED_ROUTE_REPEATER_0_INDEX        0
 166      =2  #define LAST_USED_ROUTE_REPEATER_1_INDEX        1
 167      =2  #define LAST_USED_ROUTE_REPEATER_2_INDEX        2
 168      =2  #define LAST_USED_ROUTE_REPEATER_3_INDEX        3
 169      =2  #define LAST_USED_ROUTE_CONF_INDEX              4
 170      =2  
 171      =2  
 172      =2  /* RSSI feedback constants */
 173      =2  /* This is a signed 8-bit value. Note that values from RSSI_RESERVED_START to
 174      =2   * 124 are reserved. All values below RSSI_RESERVED_START are received power
 175      =2   * in dBms. Other values are defined below. */
 176      =2  #define RSSI_NOT_AVAILABLE 127       /* RSSI measurement not available */
 177      =2  #define RSSI_MAX_POWER_SATURATED 126 /* Receiver saturated. RSSI too high to measure precisely. */
 178      =2  #define RSSI_BELOW_SENSITIVITY 125   /* No signal detected. The RSSI is too low to measure precisely. */
 179      =2  #define RSSI_RESERVED_START    11    /* All values above and including RSSI_RESERVED_START are reserved,
 180      =2                                          except those defined above. */
 181      =2  
 182      =2  
 183      =2  /* RSSI value array used in TX_STATUS_TYPE.
 184      =2   * Each value is an RSSI feedback constant defined above. */
 185      =2  struct rssi_val {
 186      =2    signed char incoming[MAX_REPEATERS + 1];
 187      =2  };
 188      =2  
 189      =2  typedef struct _S_ROUTE_LINK_
 190      =2  {
 191      =2    BYTE from;
 192      =2    BYTE to;
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 43  

 193      =2  } S_ROUTE_LINK;
 194      =2  
 195      =2  /* Transport routing scheme state define definitions */
 196      =2  /* 1 = direct, 2 = ApplicationStaticRoute, 3 = responseRoute/lastworkingRoute, */
 197      =2  /* 4 = Next to LastWorkingRoute(controller), 5 = returnRoute/controllerAutoRoute, 6 = directResort and 7 =
             - explore */
 198      =2  typedef enum _E_ROUTING_SCHEME_
 199      =2  {
 200      =2    ROUTINGSCHEME_IDLE = 0,
 201      =2    ROUTINGSCHEME_DIRECT = 1,
 202      =2    ROUTINGSCHEME_CACHED_ROUTE_SR = 2,
 203      =2    ROUTINGSCHEME_CACHED_ROUTE = 3,
 204      =2    ROUTINGSCHEME_CACHED_ROUTE_NLWR = 4,
 205      =2    ROUTINGSCHEME_ROUTE = 5,
 206      =2    ROUTINGSCHEME_RESORT_DIRECT = 6,
 207      =2    ROUTINGSCHEME_RESORT_EXPLORE = 7
 208      =2  } E_ROUTING_SCHEME;
 209      =2  
 210      =2  
 211      =2  typedef struct _TX_STATUS_TYPE_
 212      =2  {
 213      =2    WORD wTransmitTicks;  /* Passed 10ms ticks */
 214      =2    BYTE bRepeaters;         /* Repeaters in route, zero for direct range */
 215      =2    /* rssi_values per hop for direct and routed frames.
 216      =2     * Contains repeaters + 1 values. */
 217      =2    struct rssi_val rssi_values;
 218      =2    BYTE bACKChannelNo;
 219      =2    BYTE bLastTxChannelNo;
 220      =2    E_ROUTING_SCHEME bRouteSchemeState;
 221      =2    BYTE pLastUsedRoute[LAST_USED_ROUTE_SIZE];
 222      =2    BYTE bRouteTries;
 223      =2    S_ROUTE_LINK bLastFailedLink;
 224      =2  } TX_STATUS_TYPE;
 225      =2  
 226      =2  
 227      =2  typedef struct _RECEIVE_OPTIONS_TYPE
 228      =2  {
 229      =2    /* Frame header info */
 230      =2    BYTE  rxStatus;
 231      =2    /* Command sender Node ID */
 232      =2    BYTE  sourceNode;
 233      =2    /* Frame destination ID, only valid when frame is not Multicast*/
 234      =2    BYTE  destNode;
 235      =2    /* Average RSSI val in dBm as defined in RSSI feedback constants above */
 236      =2    signed char rxRSSIVal;
 237      =2    /* Security key frame was received with. */
 238      =2    enum SECURITY_KEY securityKey;
 239      =2  } RECEIVE_OPTIONS_TYPE;
 240      =2  
 241      =2  
 242      =2  #if defined(ZW_SLAVE_ENHANCED_232) || defined(ZW_SLAVE_ROUTING)
 243      =2  enum ZW_SENDDATA_EX_RETURN_CODES
 244      =2  {
 245      =2      ZW_TX_FAILED = 0,
 246      =2      ZW_TX_IN_PROGRESS = 1
 247      =2  } ;
 248      =2  
 249      =2  
 250      =2  /**
 251      =2  * This flag will activate frame delivery.
 252      =2  *
 253      =2  * In this transmission mode the S2_send_data will try
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 44  

 254      =2  * to verify that the receiver understood the sent message.
 255      =2  * This is done by waiting a little to see if the node will
 256      =2  * respond nonce report to the encrypted message. If the node
 257      =2  * does respond with a nonce report then the S2_send_data
 258      =2  * call will automatically cause the system to re-sync the node,
 259      =2  * and deliver the message
 260      =2  *
 261      =2  */
 262      =2  #define S2_TXOPTION_VERIFY_DELIVERY 1
 263      =2  
 264      =2  /**
 265      =2  * This flag must be present on all single cast followup messages.
 266      =2  */
 267      =2  #define S2_TXOPTION_SINGLECAST_FOLLOWUP 2
 268      =2  
 269      =2  /**
 270      =2  * This flag must be present on the first, and only the first single
 271      =2  * cast followup message in a S2 multicast transmission.
 272      =2  */
 273      =2  #define S2_TXOPTION_FIRST_SINGLECAST_FOLLOWUP 4
 274      =2  
 275      =2  
 276      =2  /* Transmit options for ZW_SendDataEx */
 277      =2  typedef struct _TRANSMIT_OPTIONS_TYPE
 278      =2  {
 279      =2    /* Destination node ID - 0xFF == all nodes */
 280      =2    BYTE destNode;
 281      =2    /* Reserved */
 282      =2    BYTE bSrcNode;
 283      =2    /* Transmit options*/
 284      =2    BYTE txOptions;
 285      =2    /* Options for enabling specific Security scheme functionality */
 286      =2    BYTE txSecOptions;
 287      =2    /* Security key to use for sending. */
 288      =2    enum SECURITY_KEY securityKey;
 289      =2    /* More transmit options */
 290      =2    BYTE txOptions2;
 291      =2  } TRANSMIT_OPTIONS_TYPE;
 292      =2  
 293      =2  /* Transmit options for ZW_SendDataMultiEx */
 294      =2  typedef struct _TRANSMIT_MULTI_OPTIONS_TYPE
 295      =2  {
 296      =2    /* Destination group ID */
 297      =2    BYTE groupID;
 298      =2    /* Reserved */
 299      =2    BYTE bSrcNode;
 300      =2    /* Transmit options*/
 301      =2    BYTE txOptions;
 302      =2    /* Security key to use for sending - only S2 keys are valid. */
 303      =2    enum SECURITY_KEY securityKey;
 304      =2  } TRANSMIT_MULTI_OPTIONS_TYPE;
 305      =2  
 306      =2  typedef BYTE nodemask_t[MAX_NODEMASK_LENGTH];
 307      =2  
 308      =2  #endif /* #if defined(ZW_SLAVE_ENHANCED_232) || defined(ZW_SLAVE_ROUTING) */
 309      =2  
 310      =2  
 311      =2  
 312      =2  #ifdef ZW_SLAVE_ROUTING
 313      =2  
 314      =2  /*============================   ZW_RouteDestinations   ======================
 315      =2  **    Structure description
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 45  

 316      =2  **      This contains a list of nodes that currently can be reached via
 317      =2  **      return routes.
 318      =2  **      This list MUST not be altered by the Application
 319      =2  **
 320      =2  **--------------------------------------------------------------------------*/
 321      =2  extern BYTE ZW_RouteDestinations[ZW_MAX_CACHED_RETURN_ROUTE_DESTINATIONS];
 322      =2  
 323      =2  #endif  /* ZW_SLAVE_ROUTING */
 324      =2  
 325      =2  #if defined(ZW_CONTROLLER) && !defined(ZW_CONTROLLER_BRIDGE) || (defined(ZW_SLAVE) && !defined(ZW_SLAVE_RO
             -UTING) && !defined(ZW_SLAVE_ENHANCED_232))
 353      =2  
 354      =2  #ifdef ZW_CONTROLLER_BRIDGE
 388      =2  
 389      =2  
 390      =2  #if defined(ZW_CONTROLLER) || defined(ZW_SLAVE_ROUTING)
 391      =2  
 392      =2  /*============================   ZW_SendDataAbort   ========================
 393      =2  **    Abort the ongoing transmit started with ZW_SendData()
 394      =2  **
 395      =2  **    Side effects:
 396      =2  **
 397      =2  **--------------------------------------------------------------------------*/
 398      =2  #define ZW_SEND_DATA_ABORT() ZW_SendDataAbort()
 399      =2  
 400      =2  
 401      =2  #ifndef ZW_CONTROLLER_BRIDGE
 402      =2  /*===============================   ZW_SendDataMulti   ======================
 403      =2  **    Transmit data buffer to a list of Z-Wave Nodes (multicast frame).
 404      =2  **
 405      =2  **
 406      =2  **    txOptions:
 407      =2  **          TRANSMIT_OPTION_LOW_POWER   transmit at low output power level (1/3 of
 408      =2  **                                      normal RF range).
 409      =2  **          TRANSMIT_OPTION_ACK         the multicast frame will be followed by a
 410      =2  **                                      singlecast frame to each of the destination nodes
 411      =2  **                                      and request acknowledge from each destination node.
 412      =2  **          TRANSMIT_OPTION_AUTO_ROUTE  request retransmission on singlecast frames
 413      =2  **                                      via repeater nodes (at normal output power level).
 414      =2  **
 415      =2  ** extern BYTE            RET  FALSE if transmitter queue overflow
 416      =2  ** ZW_SendDataMulti(
 417      =2  **  BYTE *pNodeIDList,     IN  List of destination node ID's
 418      =2  **  BYTE  numberNodes,     IN  Number of Nodes
 419      =2  **  BYTE *pData,           IN  Data buffer pointer
 420      =2  **  BYTE  dataLength,      IN  Data buffer length
 421      =2  **  BYTE  txOptions,       IN  Transmit option flags
 422      =2  **  VOID_CALLBACKFUNC(completedFunc)( IN  Transmit completed call back function
 423      =2  **    BYTE txStatus));     IN  Transmit status
 424      =2  **--------------------------------------------------------------------------*/
 425      =2  #define ZW_SEND_DATA_MULTI(nodelist,data,length,options,func) ZW_SendDataMulti(nodelist,data,length,option
             -s,func)
 426      =2  
 427      =2  #else
 459      =2  
 460      =2  #endif  /* ZW_CONTROLLER || ZW_SLAVE_ROUTING */
 461      =2  
 462      =2  
 463      =2  /*============================   ZW_SEND_CONST =============================
 464      =2  **    Function description
 465      =2  **      If production test is enabled during start up.
 466      =2  **      Calling this function will transmit a constant signal until a new
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 46  

 467      =2  **      RF function is called
 468      =2  **
 469      =2  **--------------------------------------------------------------------------*/
 470      =2  #define ZW_SEND_CONST() ZW_SendConst(TRUE, 1, ZW_RF_TEST_SIGNAL_CARRIER)
 471      =2  
 472      =2  
 473      =2  #ifdef ZW_SLAVE
 474      =2  /*============================ ZW_LOCK_RESPONSE_ROUTE ========================
 475      =2  **    Function description
 476      =2  **      This function locks and unlocks all return routes
 477      =2  **      IN  nodeID  != 0x00 lock route to node
 478      =2  **          nodeDI == 0x00 unlock entry
 479      =2  **    Side effects:
 480      =2  **
 481      =2  **--------------------------------------------------------------------------*/
 482      =2  #define ZW_LOCK_RESPONSE_ROUTE(node) ZW_LockRoute(node)
 483      =2  
 484      =2  #else
 499      =2  
 500      =2  
 501      =2  /****************************************************************************/
 502      =2  /*                              EXPORTED DATA                               */
 503      =2  /****************************************************************************/
 504      =2  
 505      =2  /****************************************************************************/
 506      =2  /*                           EXPORTED FUNCTIONS                             */
 507      =2  /****************************************************************************/
 508      =2  
 509      =2  #ifdef ZW_SLAVE
 510      =2  /* TO#2133 fix - Keil compiler >7.50(8.xx) seems to have been changed somehow */
 511      =2  /* in the preprocessor part as if the 2 ZW_LockRoute definitions was ifdefed */
 512      =2  /* by ifdef ZW_SLAVE ... endif and ifdef ZW_CONTROLLER ... endif instead of */
 513      =2  /* ifdef ZW_SLAVE ... else ... endif, the Keil >7.50 reports Warning C235 */
 514      =2  /* on slave/slave routing/slave enhanced targets. */
 515      =2  /*============================   ZW_LockRoute   ==============================
 516      =2  **    Function description
 517      =2  **      This function locks and unlocks any temporary route to a specific nodeID
 518      =2  **    Side effects:
 519      =2  **
 520      =2  **--------------------------------------------------------------------------*/
 521      =2  void
 522      =2  ZW_LockRoute(
 523      =2    BYTE bNodeID);          /* IN if nonezero lock bNodeID entry, */
 524      =2                            /*    zero unlock entry */
 525      =2  
 526      =2  #else  /* ZW_SLAVE */
 542      =2  
 543      =2  
 544      =2  /**============================   ZW_SendConst  =============================
 545      =2  **    Function description
 546      =2  **      Start/Stop generate RF test signal in a desired channel
 547      =2  **      Signal can be
 548      =2  **                a carrier only
 549      =2  **                a modulated carrier
 550      =2  **
 551      =2  **      Side effects:
 552      =2  **-------------------------------------------------------------------------------------------------*/
 553      =2  
 554      =2  void
 555      =2  ZW_SendConst(
 556      =2                BYTE bStart,  /*IN TRUE start sending RF test signal, FALSE disable RF test signal*/
 557      =2                BYTE bChNo,   /*IN channle number to send RF test signal on*/
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 47  

 558      =2                BYTE bSignalType ); /*IN The RF test signal type.*/
 559      =2  
 560      =2  #if defined(ZW_CONTROLLER) && !defined(ZW_CONTROLLER_BRIDGE) || (defined(ZW_SLAVE) && !defined(ZW_SLAVE_RO
             -UTING) && !defined(ZW_SLAVE_ENHANCED_232))
 594      =2  
 595      =2  #ifdef ZW_CONTROLLER_BRIDGE
 631      =2  
 632      =2  
 633      =2  /*============================   ZW_SendDataAbort   ========================
 634      =2  **    Abort the ongoing transmit started with ZW_SendData()
 635      =2  **
 636      =2  **    Side effects:
 637      =2  **
 638      =2  **--------------------------------------------------------------------------*/
 639      =2  void                /*RET FALSE if transmitter busy      */
 640      =2  ZW_SendDataAbort(void);
 641      =2  
 642      =2  
 643      =2  #ifndef ZW_CONTROLLER_BRIDGE
 644      =2  /*===============================   ZW_SendDataMulti   ======================
 645      =2  **    Transmit data buffer to a list of Z-Wave Nodes (multicast frame).
 646      =2  **
 647      =2  **
 648      =2  **    txOptions:
 649      =2  **          TRANSMIT_OPTION_LOW_POWER   transmit at low output power level (1/3 of
 650      =2  **                                      normal RF range).
 651      =2  **          TRANSMIT_OPTION_ACK         the multicast frame will be followed by a
 652      =2  **                                      singlecast frame to each of the destination nodes
 653      =2  **                                      and request acknowledge from each destination node.
 654      =2  **          TRANSMIT_OPTION_AUTO_ROUTE  request retransmission on singlecast frames via
 655      =2  **                                      repeater nodes/return routes (at normal output power level).
 656      =2  **
 657      =2  **--------------------------------------------------------------------------*/
 658      =2  extern BYTE            /*RET  FALSE if transmitter busy      */
 659      =2  ZW_SendDataMulti(
 660      =2    BYTE *pNodeIDList,          /*IN  List of destination node ID's */
 661      =2    BYTE *pData,                /*IN  Data buffer pointer           */
 662      =2    BYTE  dataLength,           /*IN  Data buffer length            */
 663      =2    BYTE  txOptions,            /*IN  Transmit option flags         */
 664      =2    VOID_CALLBACKFUNC(completedFunc)(BYTE)); /*IN  Transmit completed call back function  */
 665      =2  
 666      =2  #else
 691      =2  
 692      =2  #if defined(ZW_SLAVE_ENHANCED_232) || defined(ZW_SLAVE_ROUTING)
 693      =2  /**
 694      =2   * Send multicast security s2 encrypted frame.
 695      =2   * Only the MultiCast/Groupcast frame itself will be transmitted. There will be no single cast follow ups.
 696      =2   *
 697      =2   * \param pData             plaintext to which is going to be sent.
 698      =2   * \param dataLength        length of data to be sent.
 699      =2   * \param pTxOptionMultiEx  Transmit options structure containing the transmission source, transmit option
             -s and
 700      =2   *                          the groupID which is the connection handle for the mulicast group to use,
 701      =2   *
 702      =2   */
 703      =2  enum ZW_SENDDATA_EX_RETURN_CODES                /*RET Return code      */
 704      =2  ZW_SendDataMultiEx(
 705      =2    BYTE *pData,            /* IN Data buffer pointer           */
 706      =2    BYTE  dataLength,       /* IN Data buffer length            */
 707      =2    TRANSMIT_MULTI_OPTIONS_TYPE *pTxOptionsMultiEx,
 708      =2    VOID_CALLBACKFUNC(completedFunc)(BYTE)); /* IN Transmit completed call back function */
 709      =2  
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 48  

 710      =2  
 711      =2  /*===============================   ZW_SendDataEx   ===========================
 712      =2  **    Transmit data buffer to a single ZW-node or all ZW-nodes (broadcast).
 713      =2  **
 714      =2  **  This supersedes the old ZW_SendData and adds support for secure
 715      =2  **  transmissions.
 716      =2  **
 717      =2  **    pData                             Pointer to the payload data to be transmitted
 718      =2  **
 719      =2  **    dataLength                        Payload data length
 720      =2  **
 721      =2  **    pTxOptionsEx                      Points to Transmit options structure containing:
 722      =2  **
 723      =2  **      destNode
 724      =2  **        destination node id - 0xFF means broadcast to all nodes
 725      =2  **
 726      =2  **      bSrcNode
 727      =2  **        Reserved for future use.
 728      =2  **
 729      =2  **      txOptions:
 730      =2  **        TRANSMIT_OPTION_LOW_POWER     transmit at low output power level
 731      =2  **                                      (1/3 of normal RF range).
 732      =2  **        TRANSMIT_OPTION_ACK           the destination nodes
 733      =2  **                                      and request acknowledge from each
 734      =2  **                                      destination node.
 735      =2  **        TRANSMIT_OPTION_AUTO_ROUTE    request retransmission via return route.
 736      =2  **        TRANSMIT_OPTION_EXPLORE       Use explore frame route resolution if all else fails
 737      =2  **
 738      =2  **
 739      =2  **      securityKeys:
 740      =2  **
 741      =2  **
 742      =2  **      txOptions2
 743      =2  **
 744      =2  **
 745      =2  **--------------------------------------------------------------------------*/
 746      =2  enum ZW_SENDDATA_EX_RETURN_CODES                /*RET Return code      */
 747      =2  ZW_SendDataEx(
 748      =2    BYTE *pData,      /* IN Data buffer pointer           */
 749      =2    BYTE  dataLength, /* IN Data buffer length            */
 750      =2    TRANSMIT_OPTIONS_TYPE *pTxOptionsEx,
 751      =2    VOID_CALLBACKFUNC(completedFunc)(BYTE, TX_STATUS_TYPE*));
 752      =2  #endif /* #if defined(ZW_SLAVE_ENHANCED_232) || defined(ZW_SLAVE_ROUTING) */
 753      =2  
 754      =2  
 755      =2  #ifdef ZW_PROMISCUOUS_MODE
 767      =2  
 768      =2  /*=======================   ZW_SetListenBeforeTalkThreshold   =================
 769      =2  **    Set the threshold that should be added to the standard -75dBm used
 770      =2  **    in JP listen before talk.
 771      =2  **
 772      =2  **    Side effects:
 773      =2  **
 774      =2  **--------------------------------------------------------------------------*/
 775      =2  void                              /*RET: Nothing */
 776      =2  ZW_SetListenBeforeTalkThreshold(
 777      =2    BYTE bChannel,                  /*IN: RF channel to set the threshold for */
 778      =2    BYTE bThreshold);               /*IN: Threshold to be added to RSSI limit */
 779      =2  
 780      =2  /**
 781      =2   * Return Version on supplied Command Class if supported by protocol.
 782      =2   * If supplied Command Class not supported by protocol then UNKNOWN_VERSION is returned.
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 49  

 783      =2   *
 784      =2   * \param commandClass    command class to query for version.
 785      =2   *
 786      =2   */
 787      =2  BYTE                                  /*RET Version of supplied command class */
 788      =2  ZW_Transport_CommandClassVersionGet(
 789      =2    BYTE commandClass);                 /* IN Command class to query for version */
 790      =2  
 791      =2  
 792      =2  #endif /* _ZW_TRANSPORT_API_H_ */
 793      =2  
  16      =1  
  17      =1  /****************************************************************************/
  18      =1  /*                     EXPORTED TYPES and DEFINITIONS                       */
  19      =1  /****************************************************************************/
  20      =1  
  21      =1  /**
  22      =1   * This define holds a default set of transmit options.
  23      =1   */
  24      =1  #define ZWAVE_PLUS_TX_OPTIONS (TRANSMIT_OPTION_ACK | TRANSMIT_OPTION_AUTO_ROUTE | TRANSMIT_OPTION_EXPLORE)
  25      =1  
  26      =1  /**
  27      =1   * This define forces the function into the interbank call table. It is needed
  28      =1   * for every function which will be passed as a function pointer.
  29      =1   */
  30      =1  #ifdef __C51__
  31      =1  #define PCB(func) code const void (code * func ## _p)(void) = &func; \
  32      =1   void func
  33      =1  #else
  36      =1  
  37      =1  #ifdef __C51__
  38      =1  #define PCB_BOOL(func) code const BOOL (code * func ## _p)(void) = &func; \
  39      =1   BOOL func
  40      =1  #else
  43      =1  
  44      =1  #ifdef __C51__
  45      =1  #define PCB_UINT8_T(func) code const uint8_t (code * func ## _p)(void) = &func; \
  46      =1   uint8_t func
  47      =1  #else
  50      =1  
  51      =1  /**
  52      =1   * This define forces the function into the interbank call table. It is needed
  53      =1   * for every function which will be passed as a function pointer.
  54      =1   * "Static" keyword is added.
  55      =1   */
  56      =1  #ifdef __C51__
  57      =1  #define SPCB(func) code const void (code * func ## _p)(void) = &func; \
  58      =1   static void func
  59      =1  #else
  62      =1  
  63      =1  
  64      =1  /****************************************************************************/
  65      =1  /*                              EXPORTED DATA                               */
  66      =1  /****************************************************************************/
  67      =1  
  68      =1  
  69      =1  /****************************************************************************/
  70      =1  /*                           EXPORTED FUNCTIONS                             */
  71      =1  /****************************************************************************/
  72      =1  
  73      =1  
  74      =1  
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 50  

  75      =1  
  76      =1  /*=============================   GetMyNodeID  ===============================
  77      =1  **
  78      =1  **        Get the device node ID
  79      =1  **  Side effects: None
  80      =1  **
  81      =1  **------------------------------------------------------------------------------*/
  82      =1  extern BYTE GetMyNodeID(void);
  83      =1  
  84      =1  #endif /*#ifndef _MISC_H_*/
  32          #include <ZW_nvr_api.h>
   1      =1  /****************************************************************************
   2      =1   *
   3      =1   * Copyright (c) 2001-2013
   4      =1   * Sigma Designs, Inc.
   5      =1   * All Rights Reserved
   6      =1   *
   7      =1   *---------------------------------------------------------------------------
   8      =1   *
   9      =1   * Description: High level NVR interface functions
  10      =1   *
  11      =1   * Author:   Peter Shorty
  12      =1   *
  13      =1   * Last Changed By:  $Author: jbu $
  14      =1   * Revision:         $Revision: 58 $
  15      =1   * Last Changed:     $Date: 2009-01-12 09:45:03 +0100 (ma, 12 jan 2009) $
  16      =1   *
  17      =1   ****************************************************************************/
  18      =1  
  19      =1  #ifndef _ZW_NVR_API_H_
  20      =1  #define _ZW_NVR_API_H_
  21      =1  
  22      =1  /****************************************************************************/
  23      =1  /*                              INCLUDE FILES                               */
  24      =1  /****************************************************************************/
  25      =1  
  26      =1  /****************************************************************************/
  27      =1  /*                     EXPORTED TYPES and DEFINITIONS                       */
  28      =1  /****************************************************************************/
  29      =1  /* Start address of the application data in NVR */
  30      =1  #define NVR_APP_START_ADDRESS             0x80
  31      =1  #define NVR_APP_END_ADDRESS               0xFF
  32      =1  
  33      =1  /* Size definitions for the NVR structure */
  34      =1  #define NVR_SAW_CENTER_FREQ_SIZE      0x03
  35      =1  #define NVR_NVM_SIZE_SIZE             0x02
  36      =1  #define NVR_NVM_PAGE_SIZE_SIZE        0x02
  37      =1  #define NVR_UUID_SIZE                 0x10
  38      =1  #define NVR_USBID_SIZE                0x02
  39      =1  #define NVR_SECURITY_PUBLIC_KEY_SIZE  0x20
  40      =1  #define NVR_SECURITY_PRIVATE_KEY_SIZE 0x20
  41      =1  #define NVR_CRC16_SIZE                0x02
  42      =1  
  43      =1  /* Structure of the data in the NVR flash page */
  44      =1  typedef struct _NVR_FLASH_STRUCT_
  45      =1  {
  46      =1    BYTE  bRevision;
  47      =1    BYTE  bCrystalCalibration;
  48      =1    BYTE  bPinSwap;
  49      =1    BYTE  bNVMChipSelect;
  50      =1    BYTE  abSAWCenterFreq[NVR_SAW_CENTER_FREQ_SIZE];
  51      =1    BYTE  bSAWBandwidth;
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 51  

  52      =1    BYTE  bNVMType;
  53      =1    BYTE  bNVMSize[NVR_NVM_SIZE_SIZE];
  54      =1    BYTE  bNVMPageSize[NVR_NVM_PAGE_SIZE_SIZE];
  55      =1    BYTE  abUUID[NVR_UUID_SIZE];
  56      =1    BYTE  idVendorUsb[NVR_USBID_SIZE]; /*idVendor if 0xff -> use sigma Vendor ID (Assigned by USB Org)*/
  57      =1    BYTE  idProductUsb[NVR_USBID_SIZE];/*idProduct  if 0xff -> use sigma Product ID (Assigned by Manufacture
             -r)*/
  58      =1    BYTE  bTxCalibration1;
  59      =1    BYTE  bTxCalibration2;
  60      =1    BYTE  aSecurityPublicKey[NVR_SECURITY_PUBLIC_KEY_SIZE];
  61      =1    BYTE  aSecurityPrivateKey[NVR_SECURITY_PRIVATE_KEY_SIZE];
  62      =1  } NVR_FLASH_STRUCT;
  63      =1  
  64      =1  
  65      =1  /****************************************************************************/
  66      =1  /*                              EXPORTED DATA                               */
  67      =1  /****************************************************************************/
  68      =1  
  69      =1  /****************************************************************************/
  70      =1  /*                           EXPORTED FUNCTIONS                             */
  71      =1  /****************************************************************************/
  72      =1  
  73      =1  /*===============================   NVRGetValue   ===========================
  74      =1  **    Get a value fron the NVR flash page.
  75      =1  **
  76      =1  **    Offset 0 is the first byte in the protocol NVR area.
  77      =1  **
  78      =1  **    Offset from NVR_APP_START_ADDRESS to NVR_APP_END_ADDRESS
  79      =1  **    are NVR memory reserved for the application
  80      =1  **
  81      =1  **    If the CRC16 field in the protocol area of the NVR is not correct
  82      =1  **    all fields will return the value 0xFF when read with this function.
  83      =1  **
  84      =1  **    Side effects:  None
  85      =1  **
  86      =1  **--------------------------------------------------------------------------*/
  87      =1  void
  88      =1  ZW_NVRGetValue(BYTE bOffset, BYTE bLength, BYTE *bRetBuffer);
  89      =1  
  90      =1  
  91      =1  /*================================   ZW_NVRCheck   ==========================
  92      =1  **    Check if the NVR Flash page contains a valid CRC field
  93      =1  **
  94      =1  **    Returns:  FALSE, NVR Flash contens is not valid
  95      =1  **              TRUE,  NVR Flash contens is valid
  96      =1  **
  97      =1  **    Side effects:  Sets the bNVRValid variable
  98      =1  **
  99      =1  **--------------------------------------------------------------------------*/
 100      =1  BOOL
 101      =1  ZW_NVRCheck();
 102      =1  
 103      =1  
 104      =1  /*==============================   ZW_IsNVRValid   ===========================
 105      =1  **    Check if the NVR Flash page has been tested to contain a valid CRC field
 106      =1  **
 107      =1  **    Returns:  FALSE, NVR Flash contents is not valid
 108      =1  **              TRUE,  NVR Flash contents is valid
 109      =1  **
 110      =1  **--------------------------------------------------------------------------*/
 111      =1  BOOL
 112      =1  ZW_IsNVRValid();
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 52  

 113      =1  
 114      =1  /*============================   ZW_GetNVRRevision   =========================
 115      =1  **    Get the NVR layout revision of the NVR flash page
 116      =1  **
 117      =1  **    Returns:  The NVR layout revision of 0xFF is unknown.
 118      =1  **
 119      =1  **--------------------------------------------------------------------------*/
 120      =1  BYTE
 121      =1  ZW_GetNVRRevision();
 122      =1  
 123      =1  #endif /* _ZW_NVR_API__H_ */
  33          #include <gpio_driver.h>
   1      =1  /**
   2      =1   * @file
   3      =1   * Offers functions for controlling GPIO.
   4      =1   *
   5      =1   * This driver includes pin swap because certain Z-Wave development
   6      =1   * boards have pins which are swapped. This driver takes the pin swap into
   7      =1   * account.
   8      =1   *
   9      =1   * The GPIO driver is dependent on function gpio_GetPinSwapList() which must be
  10      =1   * placed in the application folder and implement an array of PIN_T type and
  11      =1   * the function gpio_GetPinSwapList externally declared in the header file for
  12      =1   * the GPIO driver. Function gpio_GetPinSwapList()is not called if function
  13      =1   * gpio_driver_init() is initiated with automaticPinSwap = FALSE!
  14      =1   * @copyright Copyright (c) 2001-2017, Sigma Designs Inc., All Rights Reserved
  15      =1   */
  16      =1  
  17      =1  #ifndef _GPIO_DRIVER_H_
  18      =1  #define _GPIO_DRIVER_H_
  19      =1  
  20      =1  #include <ZW_typedefs.h>
   1      =2  /*******************************  ZW_typedefs.h  *******************************
   2      =2   *           #######
   3      =2   *           ##  ##
   4      =2   *           #  ##    ####   #####    #####  ##  ##   #####
   5      =2   *             ##    ##  ##  ##  ##  ##      ##  ##  ##
   6      =2   *            ##  #  ######  ##  ##   ####   ##  ##   ####
   7      =2   *           ##  ##  ##      ##  ##      ##   #####      ##
   8      =2   *          #######   ####   ##  ##  #####       ##  #####
   9      =2   *                                           #####
  10      =2   *          Products that speak Z-Wave work together better
  11      =2   *
  12      =2   *              Copyright (c) 2008
  13      =2   *              Zensys A/S
  14      =2   *              Denmark
  15      =2   *
  16      =2   *              All Rights Reserved
  17      =2   *
  18      =2   *    This source file is subject to the terms and conditions of the
  19      =2   *    Zensys Software License Agreement which restricts the manner
  20      =2   *    in which it may be used.
  21      =2   *
  22      =2   *---------------------------------------------------------------------------
  23      =2   *
  24      =2   * Description: Module description
  25      =2   *
  26      =2   * Author:   Ivar Jeppesen
  27      =2   *
  28      =2   * Last Changed By:  $Author: efh $
  29      =2   * Revision:         $Revision: 29359 $
  30      =2   * Last Changed:     $Date: 2014-07-11 11:13:33 +0200 (fr, 11 jul 2014) $
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 53  

  31      =2   *
  32      =2   ****************************************************************************/
  33      =2  #ifndef _ZW_TYPEDEFS_H_
  21      =1  
  22      =1  typedef struct
  23      =1  {
  24      =1    BYTE pin;
  25      =1    BYTE pinSwap;
  26      =1  } PIN_T;
  27      =1  
  28      =1  typedef PIN_T PIN_T_ARRAY[];
  29      =1  
  30      =1  /**
  31      =1   * @brief Gets the pin list and its size from the application.
  32      =1   * @param[out] pPinList Pointer to an array containing the swapped pins.
  33      =1   * @param[out] pPinListSize Pointer to the size of the pin list.
  34      =1   */
  35      =1  extern void
  36      =1  gpio_GetPinSwapList(PIN_T_ARRAY xdata ** pPinList, BYTE * const pPinListSize);
  37      =1  
  38      =1  /**
  39      =1   * @brief Initializes the GPIO driver by reading out pin swap value from NVM.
  40      =1   * @param[in] automaticPinSwap Sets whether the GPIO driver should swap pins
  41      =1   * automatically or not.
  42      =1   * @return TRUE if initialized successfully, FALSE otherwise.
  43      =1   */
  44      =1  BOOL
  45      =1  gpio_DriverInit(BOOL automaticPinSwap);
  46      =1  
  47      =1  /**
  48      =1   * @brief Sets a pin as input.
  49      =1   * @param[in] pin A given pin.
  50      =1   * @param[in] fPullUp set pin to intern pull high or low
  51      =1   */
  52      =1  void gpio_SetPinIn(BYTE pin, BOOL fPullUp);
  53      =1  
  54      =1  /**
  55      =1   * @brief Sets a given pin as output.
  56      =1   * @param[in] pin A given pin.
  57      =1   */
  58      =1  void gpio_SetPinOut(BYTE pin);
  59      =1  
  60      =1  /**
  61      =1   * @brief Sets a given pin to a given state.
  62      =1   * @param[in] pin A given pin.
  63      =1   * @param[in] fValue TRUE for high, FALSE for low.
  64      =1   */
  65      =1  void gpio_SetPin(BYTE pin, BOOL fValue);
  66      =1  
  67      =1  /**
  68      =1   * @brief Returns the state of a given pin.
  69      =1   * @param[in] pin A given pin.
  70      =1   * @return TRUE if high, FALSE if low.
  71      =1   */
  72      =1  BOOL gpio_GetPin(BYTE pin);
  73      =1  
  74      =1  /**
  75      =1   * @brief Returns the state of a given pin as boolean.
  76      =1   * @param pin A given pin.
  77      =1   * @param pfState Pointer to result variable.
  78      =1   * @return TRUE if pin port exists, FALSE otherwise.
  79      =1   */
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 54  

  80      =1  BOOL gpio_GetPinBool(BYTE pin, BYTE * pfState);
  81      =1  
  82      =1  #endif /* _GPIO_DRIVER_H_ */
  83      =1  
  34          #include <ZW_sysdefs.h>
   1      =1  /*******************************  ZW_SYSDEFS.H  *****************************
   2      =1   *           #######
   3      =1   *           ##  ##
   4      =1   *           #  ##    ####   #####    #####  ##  ##   #####
   5      =1   *             ##    ##  ##  ##  ##  ##      ##  ##  ##
   6      =1   *            ##  #  ######  ##  ##   ####   ##  ##   ####
   7      =1   *           ##  ##  ##      ##  ##      ##   #####      ##
   8      =1   *          #######   ####   ##  ##  #####       ##  #####
   9      =1   *                                           #####
  10      =1   *          Z-Wave, the wireless lauguage.
  11      =1   *
  12      =1   *              Copyright (c) 2001
  13      =1   *              Zensys A/S
  14      =1   *              Denmark
  15      =1   *
  16      =1   *              All Rights Reserved
  17      =1   *
  18      =1   *    This source file is subject to the terms and conditions of the
  19      =1   *    Zensys Software License Agreement which restricts the manner
  20      =1   *    in which it may be used.
  21      =1   *
  22      =1   *---------------------------------------------------------------------------
  23      =1   *
  24      =1   * Description: Z-Wave system defines
  25      =1   *
  26      =1   * Author:   Ivar Jeppesen
  27      =1   *
  28      =1   * Last Changed By:  $Author: tro $
  29      =1   * Revision:         $Revision: 23873 $
  30      =1   * Last Changed:     $Date: 2012-12-10 10:47:43 +0100 (ma, 10 dec 2012) $
  31      =1   *
  32      =1   ****************************************************************************/
  33      =1  #ifndef _ZW_SYSDEFS_H_
  34      =1  #define _ZW_SYSDEFS_H_
  35      =1  
  36      =1  /****************************************************************************/
  37      =1  /*                              INCLUDE FILES                               */
  38      =1  /****************************************************************************/
  39      =1  #include <ZW0x0x.h>
   1      =2  /***************************************************************************
   2      =2  *
   3      =2  * Copyright (c) 2001-2011
   4      =2  * Sigma Designs, Inc.
   5      =2  * All Rights Reserved
   6      =2  *
   7      =2  *---------------------------------------------------------------------------
   8      =2  *
   9      =2  * Description: Interface file for Inventra 8051 SFR defines.
  10      =2  *
  11      =2  * Author: Thomas Roll
  12      =2  *
  13      =2  * Last Changed By: $Author: jdo $
  14      =2  * Revision: $Revision: 1.38 $
  15      =2  * Last Changed: $Date: 2005/07/27 15:12:54 $
  16      =2  *
  17      =2  ****************************************************************************/
  18      =2  
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 55  

  19      =2  
  20      =2  #ifndef _ZW0X0X_H_
  21      =2  #define _ZW0X0X_H_
  22      =2  
  23      =2  
  24      =2  #ifdef ZW040x
  27      =2  #include <ZW050x.h>
   1      =3  /*******************************  ZW050x.h  *****************************
   2      =3   *           #######
   3      =3   *           ##  ##
   4      =3   *           #  ##    ####   #####    #####  ##  ##   #####
   5      =3   *             ##    ##  ##  ##  ##  ##      ##  ##  ##
   6      =3   *            ##  #  ######  ##  ##   ####   ##  ##   ####
   7      =3   *           ##  ##  ##      ##  ##      ##   #####      ##
   8      =3   *          #######   ####   ##  ##  #####       ##  #####
   9      =3   *                                           #####
  10      =3   *          Products that speak Z-Wave work together better
  11      =3   *
  12      =3   *              Copyright (c) 2008
  13      =3   *              Zensys A/S
  14      =3   *              Denmark
  15      =3   *
  16      =3   *              All Rights Reserved
  17      =3   *
  18      =3   *    This source file is subject to the terms and conditions of the
  19      =3   *    Zensys Software License Agreement which restricts the manner
  20      =3   *    in which it may be used.
  21      =3   *
  22      =3   *---------------------------------------------------------------------------
  23      =3   *
  24      =3   * Description: Inventra 8051 SFR defines for the Z-Wave ZW050x RF transceiver.
  25      =3   *
  26      =3   * Author:   Samer Seoud
  27      =3   *
  28      =3   * Last Changed By:  $Author: sse $
  29      =3   * Revision:         $Revision: 9285 $
  30      =3   * Last Changed:     $Date: 2007-09-11 16:07:39 +0200 (Tue, 11 Sep 2007) $
  31      =3   *
  32      =3   ****************************************************************************/
  33      =3  #ifndef _ZW050X_H_
  34      =3  #define _ZW050X_H_
  35      =3  
  36      =3  sfr SFRPAGE   = 0xFF;
  37      =3  sfr ACC       = 0xE0;
  38      =3  sfr SP        = 0x81;
  39      =3  sfr PCON      = 0x87;
  40      =3  sfr TCON      = 0x88;
  41      =3  sfr TMOD      = 0x89;
  42      =3  sfr TL0       = 0x8A;
  43      =3  sfr TL1       = 0x8B;
  44      =3  sfr TH0       = 0x8C;
  45      =3  sfr TH1       = 0x8D;
  46      =3  sfr IE        = 0xA8;
  47      =3  sfr IP        = 0xB8;
  48      =3  sfr PSW       = 0xD0;
  49      =3  sfr IE_1      = 0xE8;
  50      =3  sfr B         = 0xF0;
  51      =3  sfr IP1       = 0xF8;
  52      =3  sfr DPL       = 0x82;
  53      =3  sfr DPH       = 0x83;
  54      =3  sfr P0        = 0x80;
  55      =3  sfr P1        = 0x90;
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 56  

  56      =3  sfr P2        = 0xA0;
  57      =3  sfr P3        = 0xB0;
  58      =3  sfr P0DIR     = 0xFD;
  59      =3  sfr P1DIR     = 0xC9;
  60      =3  sfr P2DIR     = 0xCA;
  61      =3  sfr P3DIR     = 0xCB;
  62      =3  
  63      =3  /******  BIT accessible Registers ******/
  64      =3  /*P0*/
  65      =3  sbit P0b0  = P0^0;
  66      =3  sbit P0b1  = P0^1;
  67      =3  sbit P0b2  = P0^2;
  68      =3  sbit P0b3  = P0^3;
  69      =3  sbit P0b4  = P0^4;
  70      =3  sbit P0b5  = P0^5;
  71      =3  sbit P0b6  = P0^6;
  72      =3  sbit P0b7  = P0^7;
  73      =3  
  74      =3  
  75      =3  /*P1*/
  76      =3  sbit P1b0  = P1^0;
  77      =3  sbit P1b1  = P1^1;
  78      =3  sbit P1b2  = P1^2;
  79      =3  sbit P1b3  = P1^3;
  80      =3  sbit P1b4  = P1^4;
  81      =3  sbit P1b5  = P1^5;
  82      =3  sbit P1b6  = P1^6;
  83      =3  sbit P1b7  = P1^7;
  84      =3  
  85      =3  /*P2*/
  86      =3  sbit P2b0  = P2^0;
  87      =3  sbit P2b1  = P2^1;
  88      =3  sbit P2b2  = P2^2;
  89      =3  sbit P2b3  = P2^3;
  90      =3  sbit P2b4  = P2^4;
  91      =3  sbit P2b5  = P2^5;
  92      =3  sbit P2b6  = P2^6;
  93      =3  sbit P2b7  = P2^7;
  94      =3  
  95      =3  /*P3*/
  96      =3  sbit P3b0  = P3^0;
  97      =3  sbit P3b1  = P3^1;
  98      =3  sbit P3b4  = P3^4;
  99      =3  sbit P3b5  = P3^5;
 100      =3  sbit P3b6  = P3^6;
 101      =3  sbit P3b7  = P3^7;
 102      =3  
 103      =3  /*  TCON  */
 104      =3  sbit TF1   = TCON^7;
 105      =3  sbit TR1   = TCON^6;
 106      =3  sbit TF0   = TCON^5;
 107      =3  sbit TR0   = TCON^4;
 108      =3  sbit IE1   = TCON^3;
 109      =3  sbit IT1   = TCON^2;
 110      =3  sbit IE0   = TCON^1;
 111      =3  sbit IT0   = TCON^0;
 112      =3  
 113      =3  /*IE*/
 114      =3  sbit EA     = IE^7;
 115      =3  sbit ES0    = IE^4;
 116      =3  sbit ET1    = IE^3;
 117      =3  sbit EX1    = IE^2;
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 57  

 118      =3  sbit ET0    = IE^1;
 119      =3  sbit EX0    = IE^0;
 120      =3  
 121      =3  /*IP*/
 122      =3  sbit PS0    = IP^4;
 123      =3  sbit PT1    = IP^3;
 124      =3  sbit PX1    = IP^2;
 125      =3  sbit PT0    = IP^1;
 126      =3  sbit PX0    = IP^0;
 127      =3  
 128      =3  /*PSW*/
 129      =3  sbit CY    = PSW^7;
 130      =3  sbit AC    = PSW^6;
 131      =3  sbit F0    = PSW^5;
 132      =3  sbit RS1   = PSW^4;
 133      =3  sbit RS0   = PSW^3;
 134      =3  sbit OV    = PSW^2;
 135      =3  sbit FL    = PSW^1;
 136      =3  sbit P     = PSW^0;
 137      =3  
 138      =3  /*IE_1*/
 139      =3  sbit ESPI0   = IE_1^7;
 140      =3  sbit EIR     = IE_1^6;
 141      =3  sbit EUSB    = IE_1^5;
 142      =3  sbit ES1     = IE_1^4;
 143      =3  sbit EADC    = IE_1^2;
 144      =3  sbit EGPT    = IE_1^1;
 145      =3  sbit ETRI    = IE_1^0;
 146      =3  
 147      =3  /*IP1*/
 148      =3  sbit PSPI0    = IP1^7;
 149      =3  sbit PIR      = IP1^6;
 150      =3  sbit PUSB     = IP1^5;
 151      =3  sbit PS1      = IP1^4;
 152      =3  sbit PADC     = IP1^2;
 153      =3  sbit PGPT     = IP1^1;
 154      =3  sbit PTRI     = IP1^0;
 155      =3  
 156      =3  /*SFR registers page select defines*/
 157      =3  #define P0_PAGE    /* ANY */
 158      =3  #define P1_PAGE    /* ANY */
 159      =3  #define P2_PAGE    /* ANY */
 160      =3  #define P3_PAGE    /* ANY */
 161      =3  // Auto-generated vvvvvvvvvvv
 162      =3  #define P0DIR_PAGE SFRPAGE=0x01
 163      =3  #define P1DIR_PAGE SFRPAGE=0x01
 164      =3  #define P2DIR_PAGE SFRPAGE=0x01
 165      =3  #define P3DIR_PAGE SFRPAGE=0x01
 166      =3    // Auto-generated ^^^^^^^^^^^^^^^^^^
 167      =3  #define IP1_PAGE   /* ANY */
 168      =3  #define B_PAGE     /* ANY */
 169      =3  #define IE1_PAGE   /* ANY */
 170      =3  #define A_PAGE     /* ANY */
 171      =3  #define PSW_PAGE   /* ANY */
 172      =3  #define IP_PAGE    /* ANY */
 173      =3  #define IE_PAGE    /* ANY */
 174      =3  #define P1_PAGE    /* ANY */
 175      =3  #define TH1_PAGE   /* ANY */
 176      =3  #define TH0_PAGE   /* ANY */
 177      =3  #define TL1_PAGE   /* ANY */
 178      =3  #define TL0_PAGE   /* ANY */
 179      =3  #define TMOD_PAGE  /* ANY */
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 58  

 180      =3  #define TCON_PAGE  /* ANY */
 181      =3  #define PCON_PAGE  /* ANY */
 182      =3  #define DPH_PAGE   /* ANY */
 183      =3  #define DPL_PAGE   /* ANY */
 184      =3  #define SP_PAGE    /* ANY */
 185      =3  #define P0_PAGE    /* ANY */
 186      =3  
 187      =3  /*SFR registers bit defines*/
 188      =3  #define P0_BITS                        0xFF
 189      =3  #define P1_BITS                        0xFF
 190      =3  #define P2_BITS                        0xFF
 191      =3  #define P3_H_BITS                      0xF0
 192      =3  #define P3_RESERVED_BITS               0x0C
 193      =3  #define P3_L_BITS                      0x03
 194      =3  #define SFRPAGE_RESERVED_BITS          0xFC
 195      =3  #define SFRPAGE_BITS                   0x03
 196      =3  
 197      =3  /* SFR macros. Sets correct page */
 198      =3  #define SFR_SET(r,v) {r##_PAGE;r=v;}
 199      =3  #define SFR_SET_MASK(r,v,m) {r##_PAGE;r=((r##)&~(m##))|((v##)&(m##));}
 200      =3  #define SFR_GET(d,r) {r##_PAGE;d=r;}
 201      =3  #define SFR_GET_MASK(d,v,r) {r##_PAGE;d=((r)&(v));}
 202      =3  #define SFR_OR(r,v) {r##_PAGE;r=(r|v);}
 203      =3  #define SFR_AND(r,v) {r##_PAGE;r=(r&v);}
 204      =3  
 205      =3  
 206      =3  
 207      =3  //ISR servicing external 0
 208      =3  #define INUM_INT0    0
 209      =3  
 210      =3  //ISR servicing timer 0
 211      =3  #define INUM_TIMER0  1
 212      =3  
 213      =3  //ISR servicing external 1
 214      =3  #define INUM_INT1    2
 215      =3  
 216      =3  //ISR servicing timer 1
 217      =3  #define INUM_TIMER1  3
 218      =3  
 219      =3  //ISR servicing serial port 0
 220      =3  #define INUM_SERIAL0 4
 221      =3  
 222      =3  //INUM servicing TRIAC
 223      =3  #define INUM_TRIAC   6
 224      =3  
 225      =3  //ISR servicing general purpose timer
 226      =3  #define INUM_GP_TIMER  7
 227      =3  
 228      =3  //ISR servicing ADC
 229      =3  #define INUM_ADC 8
 230      =3  
 231      =3  
 232      =3  //ISR servicing serial port 1
 233      =3  #define INUM_SERIAL1 10
 234      =3  
 235      =3  //ISR servicing USB
 236      =3  #define INUM_USB 11
 237      =3  
 238      =3  //ISR servicing IR
 239      =3  #define INUM_IR 12
 240      =3  
 241      =3  //ISR servicing SPI0
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 59  

 242      =3  #define INUM_SPI0 13
 243      =3  
 244      =3  //NMI servicing NMI
 245      =3  #define INUM_NMI 14
 246      =3  
 247      =3  #endif /* _ZW050X_H_ */
  28      =2  #endif
  29      =2  
  30      =2  #endif /* _ZW0X0X_H_ */
  40      =1  
  41      =1  #define __flash code
  42      =1  
  43      =1  /****************************************************************************/
  44      =1  /*                     EXPORTED TYPES and DEFINITIONS                       */
  45      =1  /****************************************************************************/
  46      =1  
  47      =1  /* Reference frequency */
  48      =1  #define CPU_FREQ  32000000
  49      =1  
  50      =1  #endif /* _ZW_SYSDEFS_H_ */
  35          #include <ZW050x.h>
   1      =1  /*******************************  ZW050x.h  *****************************
   2      =1   *           #######
   3      =1   *           ##  ##
   4      =1   *           #  ##    ####   #####    #####  ##  ##   #####
   5      =1   *             ##    ##  ##  ##  ##  ##      ##  ##  ##
   6      =1   *            ##  #  ######  ##  ##   ####   ##  ##   ####
   7      =1   *           ##  ##  ##      ##  ##      ##   #####      ##
   8      =1   *          #######   ####   ##  ##  #####       ##  #####
   9      =1   *                                           #####
  10      =1   *          Products that speak Z-Wave work together better
  11      =1   *
  12      =1   *              Copyright (c) 2008
  13      =1   *              Zensys A/S
  14      =1   *              Denmark
  15      =1   *
  16      =1   *              All Rights Reserved
  17      =1   *
  18      =1   *    This source file is subject to the terms and conditions of the
  19      =1   *    Zensys Software License Agreement which restricts the manner
  20      =1   *    in which it may be used.
  21      =1   *
  22      =1   *---------------------------------------------------------------------------
  23      =1   *
  24      =1   * Description: Inventra 8051 SFR defines for the Z-Wave ZW050x RF transceiver.
  25      =1   *
  26      =1   * Author:   Samer Seoud
  27      =1   *
  28      =1   * Last Changed By:  $Author: sse $
  29      =1   * Revision:         $Revision: 9285 $
  30      =1   * Last Changed:     $Date: 2007-09-11 16:07:39 +0200 (Tue, 11 Sep 2007) $
  31      =1   *
  32      =1   ****************************************************************************/
  33      =1  #ifndef _ZW050X_H_
  36          /****************************************************************************/
  37          /*                      PRIVATE TYPES and DEFINITIONS                       */
  38          /****************************************************************************/
  39          
  40          #ifdef ZW_DEBUG_GPIO_DRIVER
  47          #define ZW_DEBUG_GPIO_DRIVER_SEND_BYTE(data)
  48          #define ZW_DEBUG_GPIO_DRIVER_SEND_STR(STR)
  49          #define ZW_DEBUG_GPIO_DRIVER_SEND_NUM(data)
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 60  

  50          #define ZW_DEBUG_GPIO_DRIVER_SEND_WORD_NUM(data)
  51          #define ZW_DEBUG_GPIO_DRIVER_SEND_NL()
  52          #endif
  53          
  54          /****************************************************************************/
  55          /*                              PRIVATE DATA                                */
  56          /****************************************************************************/
  57          
  58          static PIN_T_ARRAY xdata * pPinSwapList = NULL;
  59          static BYTE pinListSize = 0;
  60          static BOOL fDoPinSwap = FALSE;
  61          
  62          /****************************************************************************/
  63          /*                            PRIVATE FUNCTIONS                             */
  64          /****************************************************************************/
  65          
  66          static void searchPinList(BYTE * pPin);
  67          
  68          static void
  69          searchPinList(BYTE * pPin)
  70          {
  71   1        BYTE count;
  72   1      
  73   1        for (count = 0; count < pinListSize; count++)
  74   1        {
  75   2          ZW_DEBUG_GPIO_DRIVER_SEND_NL();
  76   2          ZW_DEBUG_GPIO_DRIVER_SEND_STR("GPIO.searchPinList: pPin = ");
  77   2          ZW_DEBUG_GPIO_DRIVER_SEND_NUM(*pPin);
  78   2          ZW_DEBUG_GPIO_DRIVER_SEND_STR(", pPinSwapList[");
  79   2          ZW_DEBUG_GPIO_DRIVER_SEND_NUM(count);
  80   2          ZW_DEBUG_GPIO_DRIVER_SEND_STR("].pin = ");
  81   2          ZW_DEBUG_GPIO_DRIVER_SEND_NUM((*pPinSwapList)[count].pin);
  82   2          if ((*pPinSwapList)[count].pin == *pPin)
  83   2          {
  84   3            *pPin = (*pPinSwapList)[count].pinSwap;
  85   3            break;
  86   3          }
  87   2        }
  88   1      }
  89          
  90          /**
  91           * @brief Sets a given pin as input.
  92           * @param pin A given pin.
  93           * @param pullUp TRUE for pull up, FALSE if not.
  94           * @return TRUE if pin port exists, FALSE otherwise.
  95           */
  96          static BOOL
  97          PinIn( BYTE pin, BOOL pullUp)
  98          {
  99   1        BYTE port = pin>>4;
 100   1        BYTE portPin = pin&0x0F;
 101   1      
 102   1        switch(port)
 103   1        {
 104   2          case 0:
 105   2            P0DIR_PAGE;
 106   2            (P0ShadowDIR |= (1 << portPin));
 107   2            (pullUp)?(P0Shadow &=~(1 << portPin)):(P0Shadow |= (1 << portPin));
 108   2            P0 = P0Shadow;P0DIR = P0ShadowDIR;
 109   2            break;
 110   2          case 1:
 111   2            P1DIR_PAGE;
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 61  

 112   2            (P1ShadowDIR |= (1<<portPin));
 113   2            (pullUp)?(P1Shadow &=~(1 << portPin)):(P1Shadow |= (1 << portPin));
 114   2            P1 = P1Shadow;P1DIR = P1ShadowDIR;
 115   2            break;
 116   2          case 2:
 117   2            P2DIR_PAGE;
 118   2            (P2ShadowDIR |= (1<<portPin));
 119   2            (pullUp)?(P2Shadow &=~(1 << portPin)):(P2Shadow |= (1 << portPin));
 120   2            P2 = P2Shadow;P2DIR = P2ShadowDIR;
 121   2            break;
 122   2          case 3:
 123   2            P3DIR_PAGE;
 124   2            (P3ShadowDIR |= (1<<portPin));
 125   2            (pullUp)?(P3Shadow &=~(1 << portPin)):(P3Shadow |= (1 << portPin));
 126   2            P3 = P3Shadow;P3DIR = P3ShadowDIR;
 127   2            break;
 128   2          default: return FALSE;
 129   2        }
 130   1        return TRUE;
 131   1      }
 132          
 133          /**
 134           * @brief Sets pin as output.
 135           * @param pin A given pin.
 136           * @return TRUE if pin port exists, FALSE otherwise.
 137           */
 138          static BOOL
 139          PinOut(BYTE pin)
 140          {
 141   1        BYTE port = pin>>4;
 142   1        BYTE portPin = pin&0x0F;
 143   1      
 144   1        switch(port)
 145   1        {
 146   2          case 0:
 147   2            P0DIR_PAGE;
 148   2            P0ShadowDIR &=~(1 << portPin);
 149   2            P0DIR = P0ShadowDIR;
 150   2            break;
 151   2          case 1:
 152   2            P1DIR_PAGE;
 153   2            P1ShadowDIR &=~(1 << portPin);
 154   2            P1DIR = P1ShadowDIR;
 155   2            break;
 156   2          case 2:
 157   2            P2DIR_PAGE;
 158   2            P2ShadowDIR &=~(1 << portPin);
 159   2            P2DIR = P2ShadowDIR;
 160   2            break;
 161   2          case 3:
 162   2            P3DIR_PAGE;
 163   2            P3ShadowDIR &=~(1 << portPin);
 164   2            P3DIR = P3ShadowDIR;
 165   2            break;
 166   2          default: return FALSE;
 167   2        }
 168   1        return TRUE;
 169   1      }
 170          
 171          /**
 172           * @brief Returns the state of a given pin as boolean.
 173           * @param pin A given pin.
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 62  

 174           * @param pfState Pointer to result variable.
 175           * @return TRUE if pin port exists, FALSE otherwise.
 176           */
 177          BOOL
 178          gpio_GetPinBool(BYTE pin, BYTE * pfState)
 179          {
 180   1        BYTE port = pin>>4;
 181   1        BYTE portPin = pin&0x0F;
 182   1      
 183   1        switch(port)
 184   1        {
 185   2          case 0:
 186   2            *pfState = (P0 & (1 << portPin)) ? TRUE : FALSE;
 187   2            break;
 188   2          case 1:
 189   2            *pfState = (P1 & (1 << portPin)) ? TRUE : FALSE;
 190   2            break;
 191   2          case 2:
 192   2            *pfState = (P2 & (1 << portPin)) ? TRUE : FALSE;
 193   2            break;
 194   2          case 3:
 195   2            *pfState = (P3 & (1 << portPin)) ? TRUE : FALSE;
 196   2            break;
 197   2          default:
 198   2            return FALSE;
 199   2            break;
 200   2        }
 201   1        return TRUE;
 202   1      }
 203          
 204          /**
 205           * @brief Sets a pin high.
 206           * @param pin A given pin.
 207           */
 208          static void
 209          PinOn(BYTE pin)
 210          {
 211   1        BYTE port = pin>>4;
 212   1        BYTE portPin = pin&0x0F;
 213   1      
 214   1        switch(port)
 215   1        {
 216   2          case 0:
 217   2            P0Shadow |= (1 << portPin);
 218   2            P0 = P0Shadow;
 219   2            break;
 220   2          case 1:
 221   2            P1Shadow |= (1 << portPin);
 222   2            P1 = P1Shadow;
 223   2            break;
 224   2          case 2:
 225   2            P2Shadow |= (1 << portPin);
 226   2            P2 = P2Shadow;
 227   2            break;
 228   2          case 3:
 229   2            P3Shadow |= (1 << portPin);
 230   2            P3 = P3Shadow;
 231   2            break;
 232   2        }
 233   1        return;
 234   1      }
 235          
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 63  

 236          /**
 237           * @brief Sets a pin low.
 238           * @param pin A given pin.
 239           */
 240          static void
 241          PinOff(BYTE pin)
 242          {
 243   1        BYTE port = pin>>4;
 244   1        BYTE portPin = pin&0x0F;
 245   1      
 246   1        switch(port)
 247   1        {
 248   2          case 0:
 249   2            P0Shadow &= ~(1 << portPin);
 250   2            P0 = P0Shadow;
 251   2            break;
 252   2          case 1:
 253   2            P1Shadow &= ~(1 << portPin);
 254   2            P1 = P1Shadow;
 255   2            break;
 256   2          case 2:
 257   2            P2Shadow &= ~(1 << portPin);
 258   2            P2 = P2Shadow;
 259   2            break;
 260   2          case 3:
 261   2            P3Shadow &= ~(1 << portPin);
 262   2            P3 = P3Shadow;
 263   2            break;
 264   2        }
 265   1        return;
 266   1      }
 267          
 268          BOOL
 269          gpio_DriverInit(BOOL automaticPinSwap)
 270          {
 271   1        BYTE nvrPinSwapValue;
 272   1      
 273   1        ZW_DEBUG_GPIO_DRIVER_SEND_NL();
 274   1        ZW_DEBUG_GPIO_DRIVER_SEND_STR("GPIO init!");
 275   1      
 276   1        if (TRUE != automaticPinSwap)
 277   1        {
 278   2          ZW_DEBUG_GPIO_DRIVER_SEND_NL();
 279   2          ZW_DEBUG_GPIO_DRIVER_SEND_STR("GPIO: Exit!");
 280   2          return TRUE;
 281   2        }
 282   1      
 283   1        ZW_NVRGetValue(offsetof(NVR_FLASH_STRUCT, bPinSwap) , 1, &nvrPinSwapValue);
 284   1      
 285   1        if (1 == nvrPinSwapValue)
 286   1        {
 287   2          // The pins are swapped.
 288   2          ZW_DEBUG_GPIO_DRIVER_SEND_NL();
 289   2          ZW_DEBUG_GPIO_DRIVER_SEND_STR("GPIO: Pins swapped.");
 290   2          gpio_GetPinSwapList(&pPinSwapList, &pinListSize);
 291   2        }
 292   1        else if((0x02 <= nvrPinSwapValue) && (0xFE >= nvrPinSwapValue))
 293   1        {
 294   2          ZW_DEBUG_GPIO_DRIVER_SEND_NL();
 295   2          ZW_DEBUG_GPIO_DRIVER_SEND_STR("GPIO: Invalid value!");
 296   2          return FALSE;
 297   2        }
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 64  

 298   1      
 299   1        ZW_DEBUG_GPIO_DRIVER_SEND_NL();
 300   1        ZW_DEBUG_GPIO_DRIVER_SEND_STR("GPIO: pinListSize = ");
 301   1        ZW_DEBUG_GPIO_DRIVER_SEND_NUM(pinListSize);
 302   1        ZW_DEBUG_GPIO_DRIVER_SEND_STR("GPIO: pPinSwapList = ");
 303   1        ZW_DEBUG_GPIO_DRIVER_SEND_WORD_NUM((WORD)pPinSwapList);
 304   1        if (pinListSize > 0 && NON_NULL(pPinSwapList))
 305   1        {
 306   2          ZW_DEBUG_GPIO_DRIVER_SEND_NL();
 307   2          ZW_DEBUG_GPIO_DRIVER_SEND_STR("GPIO: Do pin swap.");
 308   2          fDoPinSwap = TRUE;
 309   2        }
 310   1      
 311   1        return TRUE;
 312   1      }
 313          
 314          void
 315          gpio_SetPinIn(BYTE pin, BOOL fPullUp)
 316          {
 317   1        if (TRUE == fDoPinSwap)
 318   1        {
 319   2          searchPinList(&pin);
 320   2        }
 321   1        PinIn(pin, fPullUp);
 322   1      }
 323          
 324          void gpio_SetPinOut(BYTE pin)
 325          {
 326   1        ZW_DEBUG_GPIO_DRIVER_SEND_NL();
 327   1        ZW_DEBUG_GPIO_DRIVER_SEND_STR("GPIO: SetPinOut = ");
 328   1        ZW_DEBUG_GPIO_DRIVER_SEND_NUM(pin);
 329   1        if (TRUE == fDoPinSwap)
 330   1        {
 331   2          searchPinList(&pin);
 332   2        }
 333   1        ZW_DEBUG_GPIO_DRIVER_SEND_STR(" swapped = ");
 334   1        ZW_DEBUG_GPIO_DRIVER_SEND_NUM(pin);
 335   1        PinOut(pin);
 336   1      }
 337          
 338          void gpio_SetPin(BYTE pin, BOOL fValue)
 339          {
 340   1        if (TRUE == fDoPinSwap)
 341   1        {
 342   2          searchPinList(&pin);
 343   2        }
 344   1        ZW_DEBUG_GPIO_DRIVER_SEND_NL();
 345   1        ZW_DEBUG_GPIO_DRIVER_SEND_STR("GPIO: SetPin ");
 346   1        ZW_DEBUG_GPIO_DRIVER_SEND_NUM(pin);
 347   1        ZW_DEBUG_GPIO_DRIVER_SEND_STR(" = ");
 348   1        ZW_DEBUG_GPIO_DRIVER_SEND_NUM(fValue);
 349   1        if (TRUE == fValue)
 350   1        {
 351   2          PinOn(pin);
 352   2        }
 353   1        else
 354   1        {
 355   2          PinOff(pin);
 356   2        }
 357   1      }
 358          
 359          BOOL gpio_GetPin(BYTE pin)
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 65  

 360          {
 361   1        BYTE fPinState;
 362   1        if (TRUE == fDoPinSwap)
 363   1        {
 364   2          searchPinList(&pin);
 365   2        }
 366   1        gpio_GetPinBool(pin, &fPinState);
 367   1        return (BOOL)fPinState;
 368   1      }
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 66  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _searchPinList (BEGIN)
                                           ; SOURCE LINE # 69
;---- Variable 'pPin' assigned to Register 'R1/R2/R3' ----
                                           ; SOURCE LINE # 70
                                           ; SOURCE LINE # 73
;---- Variable 'count' assigned to Register 'R7' ----
                       CLR     A
                       MOV     R7,A
             ?C0001:
                 R     MOV     DPTR,#pinListSize
                       MOVX    A,@DPTR
                       MOV     R6,A
                       MOV     A,R7
                       CLR     C
                       SUBB    A,R6
                 R     xJGE    ?C0005
                                           ; SOURCE LINE # 74
                                           ; SOURCE LINE # 82
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     DPL,A
                       MOV     DPH,R4
                       MOV     B,#02H
                       MOV     A,R7
                 E     CALL    ?C?OFFXADD
                       MOVX    A,@DPTR
                       MOV     R6,A
                 E     CALL    ?C?CLDPTR
                       MOV     R5,A
                       MOV     A,R6
                 R     xJNE    A,AR5,?C0003
                                           ; SOURCE LINE # 83
                                           ; SOURCE LINE # 84
                 R     MOV     DPTR,#pPinSwapList
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     DPL,A
                       MOV     DPH,R4
                       MOV     B,#02H
                       MOV     A,R7
                 E     CALL    ?C?OFFXADD
                       INC     DPTR
                       MOVX    A,@DPTR
                 E     JMP     ?C?CSTPTR
                                           ; SOURCE LINE # 85
                                           ; SOURCE LINE # 86
                                           ; SOURCE LINE # 87
             ?C0003:
                       INC     R7
                 R     xJMP    ?C0001
                                           ; SOURCE LINE # 88
             ?C0005:
                       RET     
             ; FUNCTION _searchPinList (END)

             ; FUNCTION _PinIn (BEGIN)
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 67  

                                           ; SOURCE LINE # 97
;---- Variable 'pin' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 98
                                           ; SOURCE LINE # 99
                       MOV     A,R7
                       SWAP    A
                       ANL     A,#0FH
                       MOV     R6,A
;---- Variable 'port' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 100
                       MOV     A,R7
                       ANL     A,#0FH
                       MOV     R7,A
;---- Variable 'portPin' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 102
                       MOV     A,R6
                       DEC     A
                 R     xJZ     ?C0010
                       DEC     A
                 R     xJZ     ?C0013
                       DEC     A
                 R     xJZ     ?C0016
                       ADD     A,#03H
                 R     xJNZ    ?C0019
                                           ; SOURCE LINE # 103
                                           ; SOURCE LINE # 104
             ?C0007:
                                           ; SOURCE LINE # 105
                       MOV     SFRPAGE,#01H
                                           ; SOURCE LINE # 106
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0072
             ?C0071:
                       CLR     C
                       RLC     A
             ?C0072:
                 R     DJNZ    R0,?C0071
                       MOV     R6,A
                 E     ORL     P0ShadowDIR,A
                                           ; SOURCE LINE # 107
                 R     xJNB    pullUp,?C0008
                       CPL     A
                 E     ANL     P0Shadow,A
                 R     xJMP    ?C0009
             ?C0008:
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0074
             ?C0073:
                       CLR     C
                       RLC     A
             ?C0074:
                 R     DJNZ    R0,?C0073
                 E     ORL     P0Shadow,A
             ?C0009:
                                           ; SOURCE LINE # 108
                 E     MOV     P0,P0Shadow
                 E     MOV     P0DIR,P0ShadowDIR
                                           ; SOURCE LINE # 109
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 68  

                 R     xJMP    ?C0006
                                           ; SOURCE LINE # 110
             ?C0010:
                                           ; SOURCE LINE # 111
                       MOV     SFRPAGE,#01H
                                           ; SOURCE LINE # 112
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0076
             ?C0075:
                       CLR     C
                       RLC     A
             ?C0076:
                 R     DJNZ    R0,?C0075
                       MOV     R6,A
                 E     ORL     P1ShadowDIR,A
                                           ; SOURCE LINE # 113
                 R     xJNB    pullUp,?C0011
                       CPL     A
                 E     ANL     P1Shadow,A
                 R     xJMP    ?C0012
             ?C0011:
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0078
             ?C0077:
                       CLR     C
                       RLC     A
             ?C0078:
                 R     DJNZ    R0,?C0077
                 E     ORL     P1Shadow,A
             ?C0012:
                                           ; SOURCE LINE # 114
                 E     MOV     P1,P1Shadow
                 E     MOV     P1DIR,P1ShadowDIR
                                           ; SOURCE LINE # 115
                 R     xJMP    ?C0006
                                           ; SOURCE LINE # 116
             ?C0013:
                                           ; SOURCE LINE # 117
                       MOV     SFRPAGE,#01H
                                           ; SOURCE LINE # 118
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0080
             ?C0079:
                       CLR     C
                       RLC     A
             ?C0080:
                 R     DJNZ    R0,?C0079
                       MOV     R6,A
                 E     ORL     P2ShadowDIR,A
                                           ; SOURCE LINE # 119
                 R     xJNB    pullUp,?C0014
                       CPL     A
                 E     ANL     P2Shadow,A
                 R     xJMP    ?C0015
             ?C0014:
                       MOV     A,#01H
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 69  

                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0082
             ?C0081:
                       CLR     C
                       RLC     A
             ?C0082:
                 R     DJNZ    R0,?C0081
                 E     ORL     P2Shadow,A
             ?C0015:
                                           ; SOURCE LINE # 120
                 E     MOV     P2,P2Shadow
                 E     MOV     P2DIR,P2ShadowDIR
                                           ; SOURCE LINE # 121
                 R     xJMP    ?C0006
                                           ; SOURCE LINE # 122
             ?C0016:
                                           ; SOURCE LINE # 123
                       MOV     SFRPAGE,#01H
                                           ; SOURCE LINE # 124
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0084
             ?C0083:
                       CLR     C
                       RLC     A
             ?C0084:
                 R     DJNZ    R0,?C0083
                       MOV     R6,A
                 E     ORL     P3ShadowDIR,A
                                           ; SOURCE LINE # 125
                 R     xJNB    pullUp,?C0017
                       CPL     A
                 E     ANL     P3Shadow,A
                 R     xJMP    ?C0018
             ?C0017:
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0086
             ?C0085:
                       CLR     C
                       RLC     A
             ?C0086:
                 R     DJNZ    R0,?C0085
                 E     ORL     P3Shadow,A
             ?C0018:
                                           ; SOURCE LINE # 126
                 E     MOV     P3,P3Shadow
                 E     MOV     P3DIR,P3ShadowDIR
                                           ; SOURCE LINE # 127
                 R     xJMP    ?C0006
                                           ; SOURCE LINE # 128
             ?C0019:
                       CLR     C
                       RET     
                                           ; SOURCE LINE # 129
             ?C0006:
                                           ; SOURCE LINE # 130
                       SETB    C
                                           ; SOURCE LINE # 131
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 70  

             ?C0020:
                       RET     
             ; FUNCTION _PinIn (END)

             ; FUNCTION _PinOut (BEGIN)
                                           ; SOURCE LINE # 139
;---- Variable 'pin' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 140
                                           ; SOURCE LINE # 141
                       MOV     A,R7
                       SWAP    A
                       ANL     A,#0FH
                       MOV     R6,A
;---- Variable 'port' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 142
                       MOV     A,R7
                       ANL     A,#0FH
                       MOV     R7,A
;---- Variable 'portPin' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 144
                       MOV     A,R6
                       DEC     A
                 R     xJZ     ?C0023
                       DEC     A
                 R     xJZ     ?C0024
                       DEC     A
                 R     xJZ     ?C0025
                       ADD     A,#03H
                 R     xJNZ    ?C0026
                                           ; SOURCE LINE # 145
                                           ; SOURCE LINE # 146
             ?C0022:
                                           ; SOURCE LINE # 147
                       MOV     SFRPAGE,#01H
                                           ; SOURCE LINE # 148
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0088
             ?C0087:
                       CLR     C
                       RLC     A
             ?C0088:
                 R     DJNZ    R0,?C0087
                       CPL     A
                 E     ANL     P0ShadowDIR,A
                                           ; SOURCE LINE # 149
                 E     MOV     P0DIR,P0ShadowDIR
                                           ; SOURCE LINE # 150
                 R     xJMP    ?C0021
                                           ; SOURCE LINE # 151
             ?C0023:
                                           ; SOURCE LINE # 152
                       MOV     SFRPAGE,#01H
                                           ; SOURCE LINE # 153
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0090
             ?C0089:
                       CLR     C
                       RLC     A
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 71  

             ?C0090:
                 R     DJNZ    R0,?C0089
                       CPL     A
                 E     ANL     P1ShadowDIR,A
                                           ; SOURCE LINE # 154
                 E     MOV     P1DIR,P1ShadowDIR
                                           ; SOURCE LINE # 155
                 R     xJMP    ?C0021
                                           ; SOURCE LINE # 156
             ?C0024:
                                           ; SOURCE LINE # 157
                       MOV     SFRPAGE,#01H
                                           ; SOURCE LINE # 158
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0092
             ?C0091:
                       CLR     C
                       RLC     A
             ?C0092:
                 R     DJNZ    R0,?C0091
                       CPL     A
                 E     ANL     P2ShadowDIR,A
                                           ; SOURCE LINE # 159
                 E     MOV     P2DIR,P2ShadowDIR
                                           ; SOURCE LINE # 160
                 R     xJMP    ?C0021
                                           ; SOURCE LINE # 161
             ?C0025:
                                           ; SOURCE LINE # 162
                       MOV     SFRPAGE,#01H
                                           ; SOURCE LINE # 163
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0094
             ?C0093:
                       CLR     C
                       RLC     A
             ?C0094:
                 R     DJNZ    R0,?C0093
                       CPL     A
                 E     ANL     P3ShadowDIR,A
                                           ; SOURCE LINE # 164
                 E     MOV     P3DIR,P3ShadowDIR
                                           ; SOURCE LINE # 165
                 R     xJMP    ?C0021
                                           ; SOURCE LINE # 166
             ?C0026:
                       CLR     C
                       RET     
                                           ; SOURCE LINE # 167
             ?C0021:
                                           ; SOURCE LINE # 168
                       SETB    C
                                           ; SOURCE LINE # 169
             ?C0027:
                       RET     
             ; FUNCTION _PinOut (END)

             ; FUNCTION _gpio_GetPinBool (BEGIN)
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 72  

                                           ; SOURCE LINE # 178
;---- Variable 'pfState' assigned to Register 'R1/R2/R3' ----
;---- Variable 'pin' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 179
                                           ; SOURCE LINE # 180
                       MOV     A,R7
                       SWAP    A
                       ANL     A,#0FH
                       MOV     R6,A
;---- Variable 'port' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 181
                       MOV     A,R7
                       ANL     A,#0FH
                 R     MOV     DPTR,#portPin
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 183
                       MOV     R7,AR6
                       MOV     A,R7
                       DEC     A
                 R     xJZ     ?C0032
                       DEC     A
                 R     xJZ     ?C0035
                       DEC     A
                 R     xJZ     ?C0038
                       ADD     A,#03H
                 R     xJNZ    ?C0041
                                           ; SOURCE LINE # 184
                                           ; SOURCE LINE # 185
             ?C0029:
                                           ; SOURCE LINE # 186
                 R     MOV     DPTR,#portPin
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     A,#01H
                       MOV     R6,#00H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0096
             ?C0095:
                       CLR     C
                       RLC     A
                       XCH     A,R6
                       RLC     A
                       XCH     A,R6
             ?C0096:
                 R     DJNZ    R0,?C0095
                       MOV     R7,A
                       MOV     R5,P0
                       MOV     A,R7
                       ANL     A,R5
                       MOV     R7,#00H
                 R     xJZ     ?C0030
                       MOV     R7,#01H
             ?C0030:
             ?C0031:
                                           ; SOURCE LINE # 187
                 R     xJMP    ?C0121
                                           ; SOURCE LINE # 188
             ?C0032:
                                           ; SOURCE LINE # 189
                 R     MOV     DPTR,#portPin
                       MOVX    A,@DPTR
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 73  

                       MOV     R7,A
                       MOV     A,#01H
                       MOV     R6,#00H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0098
             ?C0097:
                       CLR     C
                       RLC     A
                       XCH     A,R6
                       RLC     A
                       XCH     A,R6
             ?C0098:
                 R     DJNZ    R0,?C0097
                       MOV     R7,A
                       MOV     R5,P1
                       MOV     A,R7
                       ANL     A,R5
                       MOV     R7,#00H
                 R     xJZ     ?C0033
                       MOV     R7,#01H
             ?C0033:
             ?C0034:
             ?C0119:
                                           ; SOURCE LINE # 190
                 R     xJMP    ?C0121
                                           ; SOURCE LINE # 191
             ?C0035:
                                           ; SOURCE LINE # 192
                 R     MOV     DPTR,#portPin
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     A,#01H
                       MOV     R6,#00H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0100
             ?C0099:
                       CLR     C
                       RLC     A
                       XCH     A,R6
                       RLC     A
                       XCH     A,R6
             ?C0100:
                 R     DJNZ    R0,?C0099
                       MOV     R7,A
                       MOV     R5,P2
                       MOV     A,R7
                       ANL     A,R5
                       MOV     R7,#00H
                 R     xJZ     ?C0036
                       MOV     R7,#01H
             ?C0036:
             ?C0037:
             ?C0120:
                                           ; SOURCE LINE # 193
                 R     xJMP    ?C0121
                                           ; SOURCE LINE # 194
             ?C0038:
                                           ; SOURCE LINE # 195
                 R     MOV     DPTR,#portPin
                       MOVX    A,@DPTR
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 74  

                       MOV     R7,A
                       MOV     A,#01H
                       MOV     R6,#00H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0102
             ?C0101:
                       CLR     C
                       RLC     A
                       XCH     A,R6
                       RLC     A
                       XCH     A,R6
             ?C0102:
                 R     DJNZ    R0,?C0101
                       MOV     R7,A
                       MOV     R5,P3
                       MOV     A,R7
                       ANL     A,R5
                       MOV     R7,#00H
                 R     xJZ     ?C0039
                       MOV     R7,#01H
             ?C0039:
             ?C0040:
             ?C0121:
                       MOV     A,R7
                 E     CALL    ?C?CSTPTR
                                           ; SOURCE LINE # 196
                 R     xJMP    ?C0028
                                           ; SOURCE LINE # 197
             ?C0041:
                                           ; SOURCE LINE # 198
                       CLR     C
                       RET     
                                           ; SOURCE LINE # 199
                                           ; SOURCE LINE # 200
             ?C0028:
                                           ; SOURCE LINE # 201
                       SETB    C
                                           ; SOURCE LINE # 202
             ?C0042:
                       RET     
             ; FUNCTION _gpio_GetPinBool (END)

             ; FUNCTION _PinOn (BEGIN)
                                           ; SOURCE LINE # 209
;---- Variable 'pin' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 210
                                           ; SOURCE LINE # 211
                       MOV     A,R7
                       SWAP    A
                       ANL     A,#0FH
                       MOV     R6,A
;---- Variable 'port' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 212
                       MOV     A,R7
                       ANL     A,#0FH
                       MOV     R7,A
;---- Variable 'portPin' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 214
                       MOV     A,R6
                       DEC     A
                 R     xJZ     ?C0045
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 75  

                       DEC     A
                 R     xJZ     ?C0046
                       DEC     A
                 R     xJZ     ?C0047
                       ADD     A,#03H
                 R     xJNZ    ?C0048
                                           ; SOURCE LINE # 215
                                           ; SOURCE LINE # 216
             ?C0044:
                                           ; SOURCE LINE # 217
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0104
             ?C0103:
                       CLR     C
                       RLC     A
             ?C0104:
                 R     DJNZ    R0,?C0103
                 E     ORL     P0Shadow,A
                                           ; SOURCE LINE # 218
                 E     MOV     P0,P0Shadow
                                           ; SOURCE LINE # 219
                       RET     
                                           ; SOURCE LINE # 220
             ?C0045:
                                           ; SOURCE LINE # 221
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0106
             ?C0105:
                       CLR     C
                       RLC     A
             ?C0106:
                 R     DJNZ    R0,?C0105
                 E     ORL     P1Shadow,A
                                           ; SOURCE LINE # 222
                 E     MOV     P1,P1Shadow
                                           ; SOURCE LINE # 223
                       RET     
                                           ; SOURCE LINE # 224
             ?C0046:
                                           ; SOURCE LINE # 225
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0108
             ?C0107:
                       CLR     C
                       RLC     A
             ?C0108:
                 R     DJNZ    R0,?C0107
                 E     ORL     P2Shadow,A
                                           ; SOURCE LINE # 226
                 E     MOV     P2,P2Shadow
                                           ; SOURCE LINE # 227
                       RET     
                                           ; SOURCE LINE # 228
             ?C0047:
                                           ; SOURCE LINE # 229
                       MOV     A,#01H
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 76  

                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0110
             ?C0109:
                       CLR     C
                       RLC     A
             ?C0110:
                 R     DJNZ    R0,?C0109
                 E     ORL     P3Shadow,A
                                           ; SOURCE LINE # 230
                 E     MOV     P3,P3Shadow
                                           ; SOURCE LINE # 231
                                           ; SOURCE LINE # 232
                                           ; SOURCE LINE # 234
             ?C0048:
                       RET     
             ; FUNCTION _PinOn (END)

             ; FUNCTION _PinOff (BEGIN)
                                           ; SOURCE LINE # 241
;---- Variable 'pin' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 242
                                           ; SOURCE LINE # 243
                       MOV     A,R7
                       SWAP    A
                       ANL     A,#0FH
                       MOV     R6,A
;---- Variable 'port' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 244
                       MOV     A,R7
                       ANL     A,#0FH
                       MOV     R7,A
;---- Variable 'portPin' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 246
                       MOV     A,R6
                       DEC     A
                 R     xJZ     ?C0051
                       DEC     A
                 R     xJZ     ?C0052
                       DEC     A
                 R     xJZ     ?C0053
                       ADD     A,#03H
                 R     xJNZ    ?C0054
                                           ; SOURCE LINE # 247
                                           ; SOURCE LINE # 248
             ?C0050:
                                           ; SOURCE LINE # 249
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0112
             ?C0111:
                       CLR     C
                       RLC     A
             ?C0112:
                 R     DJNZ    R0,?C0111
                       CPL     A
                 E     ANL     P0Shadow,A
                                           ; SOURCE LINE # 250
                 E     MOV     P0,P0Shadow
                                           ; SOURCE LINE # 251
                       RET     
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 77  

                                           ; SOURCE LINE # 252
             ?C0051:
                                           ; SOURCE LINE # 253
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0114
             ?C0113:
                       CLR     C
                       RLC     A
             ?C0114:
                 R     DJNZ    R0,?C0113
                       CPL     A
                 E     ANL     P1Shadow,A
                                           ; SOURCE LINE # 254
                 E     MOV     P1,P1Shadow
                                           ; SOURCE LINE # 255
                       RET     
                                           ; SOURCE LINE # 256
             ?C0052:
                                           ; SOURCE LINE # 257
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0116
             ?C0115:
                       CLR     C
                       RLC     A
             ?C0116:
                 R     DJNZ    R0,?C0115
                       CPL     A
                 E     ANL     P2Shadow,A
                                           ; SOURCE LINE # 258
                 E     MOV     P2,P2Shadow
                                           ; SOURCE LINE # 259
                       RET     
                                           ; SOURCE LINE # 260
             ?C0053:
                                           ; SOURCE LINE # 261
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0118
             ?C0117:
                       CLR     C
                       RLC     A
             ?C0118:
                 R     DJNZ    R0,?C0117
                       CPL     A
                 E     ANL     P3Shadow,A
                                           ; SOURCE LINE # 262
                 E     MOV     P3,P3Shadow
                                           ; SOURCE LINE # 263
                                           ; SOURCE LINE # 264
                                           ; SOURCE LINE # 266
             ?C0054:
                       RET     
             ; FUNCTION _PinOff (END)

             ; FUNCTION gpio_DriverInit (BEGIN)
                                           ; SOURCE LINE # 269
                                           ; SOURCE LINE # 270
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 78  

                                           ; SOURCE LINE # 276
                 R     xJB     automaticPinSwap,?C0055
                                           ; SOURCE LINE # 277
                                           ; SOURCE LINE # 280
                       SETB    C
                       RET     
                                           ; SOURCE LINE # 281
             ?C0055:
                                           ; SOURCE LINE # 283
                       MOV     R3,#01H
                 R     MOV     R2,#HIGH nvrPinSwapValue
                 R     MOV     R1,#LOW nvrPinSwapValue
                       MOV     R5,#01H
                       MOV     R7,#02H
                 E     CALL    _ZW_NVRGetValue
                                           ; SOURCE LINE # 285
                 R     MOV     DPTR,#nvrPinSwapValue
                       MOVX    A,@DPTR
                 R     xJNE    A,#01H,?C0057
                                           ; SOURCE LINE # 286
                                           ; SOURCE LINE # 290
                       MOV     R3,#01H
                 R     MOV     R2,#HIGH pinListSize
                 R     MOV     R1,#LOW pinListSize
                 E     MOV     DPTR,#?_gpio_GetPinSwapList?BYTE+03H
                 E     CALL    ?C?PSTXDATA
                 R     MOV     R2,#HIGH pPinSwapList
                       INC     R1
                 E     CALL    _gpio_GetPinSwapList
                                           ; SOURCE LINE # 291
                 R     xJMP    ?C0058
             ?C0057:
                                           ; SOURCE LINE # 292
                 R     MOV     DPTR,#nvrPinSwapValue
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     A,#02H
                       SETB    C
                       SUBB    A,R7
                 R     xJGE    ?C0058
                       MOV     A,#0FEH
                       CLR     C
                       SUBB    A,R7
                 R     xJLT    ?C0058
                                           ; SOURCE LINE # 293
                                           ; SOURCE LINE # 296
                       RET     
                                           ; SOURCE LINE # 297
             ?C0058:
                                           ; SOURCE LINE # 304
                 R     MOV     DPTR,#pinListSize
                       MOVX    A,@DPTR
                       SETB    C
                       SUBB    A,#00H
                 R     xJLT    ?C0060
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       ORL     A,R6
                 R     xJZ     ?C0060
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 79  

                                           ; SOURCE LINE # 305
                                           ; SOURCE LINE # 308
                 R     SETB    fDoPinSwap
                                           ; SOURCE LINE # 309
             ?C0060:
                                           ; SOURCE LINE # 311
                       SETB    C
                                           ; SOURCE LINE # 312
             ?C0056:
                       RET     
             ; FUNCTION gpio_DriverInit (END)

             ; FUNCTION _gpio_SetPinIn (BEGIN)
                                           ; SOURCE LINE # 315
                 R     MOV     DPTR,#pin
                       MOV     A,R7
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 316
                                           ; SOURCE LINE # 317
                 R     xJNB    fDoPinSwap,?C0061
                                           ; SOURCE LINE # 318
                                           ; SOURCE LINE # 319
                       MOV     R3,#01H
                 R     MOV     R2,#HIGH pin
                 R     MOV     R1,#LOW pin
                 R     CALL    _searchPinList
                                           ; SOURCE LINE # 320
             ?C0061:
                                           ; SOURCE LINE # 321
                 R     MOV     DPTR,#pin
                       MOVX    A,@DPTR
                       MOV     R7,A
                 R     MOV     C,fPullUp
                 R     MOV     ?_PinIn?BIT,C
                 R     JMP     _PinIn
             ; FUNCTION _gpio_SetPinIn (END)

             ; FUNCTION _gpio_SetPinOut (BEGIN)
                                           ; SOURCE LINE # 324
                 R     MOV     DPTR,#pin
                       MOV     A,R7
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 325
                                           ; SOURCE LINE # 329
                 R     xJNB    fDoPinSwap,?C0063
                                           ; SOURCE LINE # 330
                                           ; SOURCE LINE # 331
                       MOV     R3,#01H
                 R     MOV     R2,#HIGH pin
                 R     MOV     R1,#LOW pin
                 R     CALL    _searchPinList
                                           ; SOURCE LINE # 332
             ?C0063:
                                           ; SOURCE LINE # 335
                 R     MOV     DPTR,#pin
                       MOVX    A,@DPTR
                       MOV     R7,A
                 R     JMP     _PinOut
             ; FUNCTION _gpio_SetPinOut (END)

             ; FUNCTION _gpio_SetPin (BEGIN)
                                           ; SOURCE LINE # 338
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 80  

                 R     MOV     DPTR,#pin
                       MOV     A,R7
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 339
                                           ; SOURCE LINE # 340
                 R     xJNB    fDoPinSwap,?C0065
                                           ; SOURCE LINE # 341
                                           ; SOURCE LINE # 342
                       MOV     R3,#01H
                 R     MOV     R2,#HIGH pin
                 R     MOV     R1,#LOW pin
                 R     CALL    _searchPinList
                                           ; SOURCE LINE # 343
             ?C0065:
                                           ; SOURCE LINE # 349
                 R     MOV     DPTR,#pin
                       MOVX    A,@DPTR
                       MOV     R7,A
                 R     xJNB    fValue,?C0066
                                           ; SOURCE LINE # 350
                                           ; SOURCE LINE # 351
                 R     JMP     _PinOn
                                           ; SOURCE LINE # 352
             ?C0066:
                                           ; SOURCE LINE # 354
                                           ; SOURCE LINE # 355
                 R     CALL    _PinOff
                                           ; SOURCE LINE # 356
                                           ; SOURCE LINE # 357
             ?C0068:
                       RET     
             ; FUNCTION _gpio_SetPin (END)

             ; FUNCTION _gpio_GetPin (BEGIN)
                                           ; SOURCE LINE # 359
                 R     MOV     DPTR,#pin
                       MOV     A,R7
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 360
                                           ; SOURCE LINE # 362
                 R     xJNB    fDoPinSwap,?C0069
                                           ; SOURCE LINE # 363
                                           ; SOURCE LINE # 364
                       MOV     R3,#01H
                 R     MOV     R2,#HIGH pin
                 R     MOV     R1,#LOW pin
                 R     CALL    _searchPinList
                                           ; SOURCE LINE # 365
             ?C0069:
                                           ; SOURCE LINE # 366
                 R     MOV     DPTR,#pin
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     R3,#01H
                 R     MOV     R2,#HIGH fPinState
                 R     MOV     R1,#LOW fPinState
                 R     CALL    _gpio_GetPinBool
                                           ; SOURCE LINE # 367
                 R     MOV     DPTR,#fPinState
                       MOVX    A,@DPTR
                       ADD     A,#0FFH
                                           ; SOURCE LINE # 368
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 81  

             ?C0070:
                       RET     
             ; FUNCTION _gpio_GetPin (END)

C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 82  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


sSomeXDATA4K . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  1
  anything . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
ROUTINGSCHEME_DIRECT . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DWORD. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
AC . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D6H  1
pinListSize. . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0000H  1
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
_TRANSMIT_OPTIONS_TYPE . . . . . . . .  * TAG *  -----  STRUCT   -----  6
  destNode . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bSrcNode . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  txOptions. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  txSecOptions . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  securityKey. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  txOptions2 . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
SFRPAGE. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FFH  1
_S_SECURITY_S2_INCLUSION_CSA_PUBLIC_DSK_* TAG *  -----  STRUCT   -----  4
  aCSA_DSK . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
EADC . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
IE . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
NVR_FLASH_STRUCT . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  99
  bRevision. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bCrystalCalibration. . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  bPinSwap . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  bNVMChipSelect . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  abSAWCenterFreq. . . . . . . . . . .  MEMBER   -----  ARRAY    0004H  3
  bSAWBandwidth. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  bNVMType . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
  bNVMSize . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0009H  2
  bNVMPageSize . . . . . . . . . . . .  MEMBER   -----  ARRAY    000BH  2
  abUUID . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    000DH  16
  idVendorUsb. . . . . . . . . . . . .  MEMBER   -----  ARRAY    001DH  2
  idProductUsb . . . . . . . . . . . .  MEMBER   -----  ARRAY    001FH  2
  bTxCalibration1. . . . . . . . . . .  MEMBER   -----  U_CHAR   0021H  1
  bTxCalibration2. . . . . . . . . . .  MEMBER   -----  U_CHAR   0022H  1
  aSecurityPublicKey . . . . . . . . .  MEMBER   -----  ARRAY    0023H  32
  aSecurityPrivateKey. . . . . . . . .  MEMBER   -----  ARRAY    0043H  32
ZW_TX_IN_PROGRESS. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
FL . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D1H  1
P0b0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0080H  1
P1b0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
P0b1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0081H  1
_S_ROUTE_LINK_ . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  2
  from . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  to . . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
P2b0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
P1b1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
P0b2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0082H  1
P3b0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
P2b1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
P1b2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
P0b3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0083H  1
P3b1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
P2b2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 83  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


P1b3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
P0b4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0084H  1
P2b3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
P1b4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
P0b5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0085H  1
TRANSMIT_MULTI_OPTIONS_TYPE. . . . . .  TYPEDEF  -----  STRUCT   -----  4
  groupID. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bSrcNode . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  txOptions. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  securityKey. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
TX_STATUS_TYPE . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  19
  wTransmitTicks . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  bRepeaters . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  rssi_values. . . . . . . . . . . . .  MEMBER   -----  STRUCT   0003H  5
  bACKChannelNo. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
  bLastTxChannelNo . . . . . . . . . .  MEMBER   -----  U_CHAR   0009H  1
  bRouteSchemeState. . . . . . . . . .  MEMBER   -----  U_CHAR   000AH  1
  pLastUsedRoute . . . . . . . . . . .  MEMBER   -----  ARRAY    000BH  5
  bRouteTries. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0010H  1
  bLastFailedLink. . . . . . . . . . .  MEMBER   -----  STRUCT   0011H  2
PADC . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FAH  1
P2b4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
P1b5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
P0b6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0086H  1
IP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
gpio_DriverInit. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  automaticPinSwap . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
  nvrPinSwapValue. . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
P3b4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
P2b5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
P1b6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
P0b7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0087H  1
_gpio_GetPinSwapList . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_RECEIVE_OPTIONS_TYPE. . . . . . . . .  * TAG *  -----  STRUCT   -----  5
  rxStatus . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  sourceNode . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  destNode . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  rxRSSIVal. . . . . . . . . . . . . .  MEMBER   -----  CHAR     0003H  1
  securityKey. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
P3b5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
P2b6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
P1b7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
e_application_security_event_t . . . .  TYPEDEF  -----  U_CHAR   -----  1
CY . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D7H  1
P3b6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
P2b7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
PIN_T. . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  pin. . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  pinSwap. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
P3b7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
IE_1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
_gpio_SetPinIn . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  pin. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  fPullUp. . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
SP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0081H  1
_gpio_SetPinOut. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  pin. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 84  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


XDATA4K_P. . . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
OV . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D2H  1
s_application_security_event_data_t. .  TYPEDEF  -----  STRUCT   -----  5
  event. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  eventDataLength. . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  eventData. . . . . . . . . . . . . .  MEMBER   -----  PTR      0002H  3
_E_ROUTING_SCHEME_ . . . . . . . . . .  * TAG *  -----  ENUM     -----  -----
E_APPLICATION_SECURITY_EVENT_S2_INCLUS  E_CONST  -----  U_CHAR   -----  1
ROUTINGSCHEME_RESORT_EXPLORE . . . . .  E_CONST  -----  U_CHAR   -----  1
TRANSMIT_OPTIONS_TYPE. . . . . . . . .  TYPEDEF  -----  STRUCT   -----  6
  destNode . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bSrcNode . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  txOptions. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  txSecOptions . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  securityKey. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  txOptions2 . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
SECURITY_KEY_S0. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_ZW_NVRGetValue. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
nodemask_t . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  29
EUSB . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EDH  1
EGPT . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E9H  1
PCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
DWORD_P. . . . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
ETRI . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E8H  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
BYTE . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
RECEIVE_OPTIONS_TYPE . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  rxStatus . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  sourceNode . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  destNode . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  rxRSSIVal. . . . . . . . . . . . . .  MEMBER   -----  CHAR     0003H  1
  securityKey. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
PUSB . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FDH  1
PGPT . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F9H  1
SECURITY_AUTHENTICATION_CSA. . . . . .  E_CONST  -----  U_CHAR   -----  1
WORD . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
IE0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0089H  1
IE1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008BH  1
PTRI . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F8H  1
B. . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F0H  1
SECURITY_KEY_S2_ACCESS . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_searchPinList . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  pPin . . . . . . . . . . . . . . . .  * REG *  DATA   PTR      0001H  3
  count. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
ROUTINGSCHEME_RESORT_DIRECT. . . . . .  E_CONST  -----  U_CHAR   -----  1
_PinOff. . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  pin. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  port . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
  portPin. . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
ZW_TX_FAILED . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
SECURITY_KEY . . . . . . . . . . . . .  * TAG *  -----  ENUM     -----  -----
ACC. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E0H  1
ES0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
ES1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ECH  1
ET0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
ET1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 85  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TF0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008DH  1
IP1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
TF1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008FH  1
P0ShadowDIR. . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
SECURITY_AUTHENTICATION_SSA. . . . . .  E_CONST  -----  U_CHAR   -----  1
P1ShadowDIR. . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
EX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A8H  1
IT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0088H  1
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
P2ShadowDIR. . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
EX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AAH  1
IT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008AH  1
_E_SECURTIY_S2_AUTHENTICATION_ . . . .  * TAG *  -----  ENUM     -----  -----
P3ShadowDIR. . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
P. . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D0H  1
_NVR_FLASH_STRUCT_ . . . . . . . . . .  * TAG *  -----  STRUCT   -----  99
  bRevision. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bCrystalCalibration. . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  bPinSwap . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  bNVMChipSelect . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  abSAWCenterFreq. . . . . . . . . . .  MEMBER   -----  ARRAY    0004H  3
  bSAWBandwidth. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  bNVMType . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
  bNVMSize . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0009H  2
  bNVMPageSize . . . . . . . . . . . .  MEMBER   -----  ARRAY    000BH  2
  abUUID . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    000DH  16
  idVendorUsb. . . . . . . . . . . . .  MEMBER   -----  ARRAY    001DH  2
  idProductUsb . . . . . . . . . . . .  MEMBER   -----  ARRAY    001FH  2
  bTxCalibration1. . . . . . . . . . .  MEMBER   -----  U_CHAR   0021H  1
  bTxCalibration2. . . . . . . . . . .  MEMBER   -----  U_CHAR   0022H  1
  aSecurityPublicKey . . . . . . . . .  MEMBER   -----  ARRAY    0023H  32
  aSecurityPrivateKey. . . . . . . . .  MEMBER   -----  ARRAY    0043H  32
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
ROUTINGSCHEME_CACHED_ROUTE . . . . . .  E_CONST  -----  U_CHAR   -----  1
TL1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008BH  1
PS0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
PS1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FCH  1
PT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
S_ROUTE_LINK . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  from . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  to . . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
RS0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D3H  1
PT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
ROUTINGSCHEME_ROUTE. . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
pPinSwapList . . . . . . . . . . . . .  STATIC   XDATA  PTR      0001H  2
RS1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D4H  1
TR0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
ROUTINGSCHEME_CACHED_ROUTE_SR. . . . .  E_CONST  -----  U_CHAR   -----  1
SECURITY_KEY_S2_AUTHENTICATED. . . . .  E_CONST  -----  U_CHAR   -----  1
TR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
_TX_STATUS_TYPE_ . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  19
  wTransmitTicks . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  bRepeaters . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  rssi_values. . . . . . . . . . . . .  MEMBER   -----  STRUCT   0003H  5
  bACKChannelNo. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
  bLastTxChannelNo . . . . . . . . . .  MEMBER   -----  U_CHAR   0009H  1
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 86  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  bRouteSchemeState. . . . . . . . . .  MEMBER   -----  U_CHAR   000AH  1
  pLastUsedRoute . . . . . . . . . . .  MEMBER   -----  ARRAY    000BH  5
  bRouteTries. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0010H  1
  bLastFailedLink. . . . . . . . . . .  MEMBER   -----  STRUCT   0011H  2
PX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
SECURITY_KEY_NONE. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
PX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
DPH. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0083H  1
_gpio_GetPin . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  pin. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  fPinState. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
_E_APPLICATION_SECURITY_EVENT_ . . . .  * TAG *  -----  ENUM     -----  -----
_PinIn . . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  pin. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  pullUp . . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
  port . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
  portPin. . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
EIR. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EEH  1
P0DIR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
DPL. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0082H  1
fDoPinSwap . . . . . . . . . . . . . .  STATIC   DATA   BIT      0000H  1
P1DIR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
_PinOut. . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  pin. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  port . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
  portPin. . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
ESPI0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EFH  1
P2DIR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
P3DIR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
ROUTINGSCHEME_IDLE . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
BYTE_P . . . . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
_PinOn . . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  pin. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  port . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
  portPin. . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
s_SecurityS2InclusionCSAPublicDSK_t. .  TYPEDEF  -----  STRUCT   -----  4
  aCSA_DSK . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
_gpio_SetPin . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  pin. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  fValue . . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
E_ROUTING_SCHEME . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
rssi_val . . . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  5
  incoming . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  5
_S_APPLICATION_SECURITY_EVENT_DATA_. .  * TAG *  -----  STRUCT   -----  5
  event. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  eventDataLength. . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  eventData. . . . . . . . . . . . . .  MEMBER   -----  PTR      0002H  3
e_security_s2_authentication_t . . . .  TYPEDEF  -----  U_CHAR   -----  1
P0Shadow . . . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
PIR. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FEH  1
_gpio_GetPinBool . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  pin. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  pfState. . . . . . . . . . . . . . .  * REG *  DATA   PTR      0001H  3
  port . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
  portPin. . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
ZW_SENDDATA_EX_RETURN_CODES. . . . . .  * TAG *  -----  ENUM     -----  -----
P1Shadow . . . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
C51 COMPILER V9.54   GPIO_DRIVER                                                           11/21/2021 08:16:53 PAGE 87  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


P2Shadow . . . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
PSPI0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FFH  1
P3Shadow . . . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
WORD_P . . . . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
F0 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D5H  1
ROUTINGSCHEME_CACHED_ROUTE_NLWR. . . .  E_CONST  -----  U_CHAR   -----  1
_TRANSMIT_MULTI_OPTIONS_TYPE . . . . .  * TAG *  -----  STRUCT   -----  4
  groupID. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bSrcNode . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  txOptions. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  securityKey. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
SECURITY_KEY_S2_UNAUTHENTICATED. . . .  E_CONST  -----  U_CHAR   -----  1
PIN_T_ARRAY. . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  -----
security_key_t . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1124    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      3       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       4
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
